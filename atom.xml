<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sevenの博客</title>
  
  <subtitle>时光，不会辜负每一个平静努力的人</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://seven1011.github.io/"/>
  <updated>2020-01-08T01:00:25.685Z</updated>
  <id>https://seven1011.github.io/</id>
  
  <author>
    <name>Seven</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>运算符优先级</title>
    <link href="https://seven1011.github.io/2020/01/08/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7/"/>
    <id>https://seven1011.github.io/2020/01/08/运算符优先级/</id>
    <published>2020-01-07T22:30:51.000Z</published>
    <updated>2020-01-08T01:00:25.685Z</updated>
    
    <content type="html"><![CDATA[<pre><code>运算符优先级</code></pre><a id="more"></a><p><img src="/images/picture/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7.png" alt="运算符优先级表格"></p><hr><p><strong>参考来源：</strong>【赛迪网-IT技术报道】在实际的开发中，可能在一个运算符中出现多个运算符，那么计算时，就按照优先级级别的高低进行计算，级别高的运算符先运算，级别低的运算符后计算</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;运算符优先级&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://seven1011.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://seven1011.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>StringBuffer中常用的方法总结</title>
    <link href="https://seven1011.github.io/2020/01/04/StringBuffer%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>https://seven1011.github.io/2020/01/04/StringBuffer中常用的方法总结/</id>
    <published>2020-01-04T09:21:06.000Z</published>
    <updated>2020-01-04T01:30:44.658Z</updated>
    
    <content type="html"><![CDATA[<pre><code>对StringBuffer中常用的方法进行总结</code></pre><a id="more"></a><h3 id="1-构造方法"><a href="#1-构造方法" class="headerlink" title="1.构造方法"></a>1.构造方法</h3><pre><code>a. StringBuffer s0=new StringBuffer();分配了长16字节的字符缓冲区b. StringBuffer s1=new StringBuffer(100);分配了100字节的字符缓冲区c. StringBuffer s2=new StringBuffer(&quot;Hello World!&quot;);</code></pre><br><h3 id="2-常用方法"><a href="#2-常用方法" class="headerlink" title="2.常用方法"></a>2.常用方法</h3><p><strong>(1) 字符获取替换</strong></p><pre><code>charAt(int index);    //获取指定位置的字符setCharAt(int index,char ch);    //将指定的字符ch放到index指出的位置。replace(int start,int end,String str);   //替换从start(包含)到end(不包含)的值为str(可以大于end-start)substring(int start);  //返回从start下标开始以后的字符串substring(int start, int end);   //返回从start到end-1的字符串</code></pre><p><strong>(2) 字符的插入</strong></p><pre><code>insert(int offset,char ch);   //在offset位置插入字符ch。append(char ch);  //在末尾插入内容</code></pre><p><strong>(3) 字符串容量</strong></p><pre><code>capacity(String str);  //获取字符串的容量ensureCapacity();   //重新设置字符串容量的大小</code></pre><p><strong>(4) 设置字符缓冲区的大小</strong></p><pre><code>setlength();   //如果用小于当前字符串长度的值调用setlength()方法，则新长度后面的字符将丢失。</code></pre><p><strong>(5) 字符串反转</strong></p><pre><code>reverse();  //将字符串逆序排列</code></pre><p><strong>(6) 将字符串的的子字符复制给数组</strong></p><pre><code>getChars(int start,int end,char chars[],int charsStart);</code></pre><p><strong>(7) 删除指定字符串中的数组</strong></p><pre><code>delete(int start,int end); //删除区间以内的所有字符，包括start，不包括enddeleteCharAt(int index); //删除指定位置的字符，将剩余的内容形成从的字符串</code></pre><hr><p>参考文章：&#160; <a href="https://www.cnblogs.com/liu-chao-feng/p/5636063.html" target="_blank" rel="noopener">《StringBuffer的用法》</a></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;对StringBuffer中常用的方法进行总结&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://seven1011.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https://seven1011.github.io/tags/java/"/>
    
      <category term="StringBuffer" scheme="https://seven1011.github.io/tags/StringBuffer/"/>
    
  </entry>
  
  <entry>
    <title>StringBuffer和String的相互转换</title>
    <link href="https://seven1011.github.io/2020/01/04/StringBuffer%E5%92%8CString%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/"/>
    <id>https://seven1011.github.io/2020/01/04/StringBuffer和String的相互转换/</id>
    <published>2020-01-04T09:20:06.000Z</published>
    <updated>2020-01-04T01:33:39.491Z</updated>
    
    <content type="html"><![CDATA[<pre><code>String转StringBuffer、StringBuffer转String各有两种方法</code></pre><a id="more"></a><h3 id="String转StringBuffer："><a href="#String转StringBuffer：" class="headerlink" title="String转StringBuffer："></a><strong>String转StringBuffer：</strong></h3><ol><li>构造方法转换</li><li>append()方法<br></li></ol><p><strong>代码示例：</strong></p><pre><code>package test_01;/*String 转StringBuffer*/        public class StringBufferDemo {        public static void main(String[] args) {        //String --&gt; StringBuffer        String string = &quot;Hello&quot;;        //构造方法转换         StringBuffer buffer = new StringBuffer(string);         System.out.println(buffer);     //append()方法     StringBuffer buffer2 = new StringBuffer();     buffer2.append(string);     System.out.println(&quot;buffer2:&quot;+buffer2);        }    }</code></pre><h3 id="StringBuffer转String："><a href="#StringBuffer转String：" class="headerlink" title="StringBuffer转String："></a>StringBuffer转String：</h3><ol><li>构造方法转换</li><li>toString()方法<br></li></ol><p><strong>代码示例：</strong></p><pre><code>package test_01;/* * StringBuffer转String */public class StringBufferDemo {    public static void main(String[] args) {        //StringBuffer --&gt;  String         StringBuffer buffer = new StringBuffer(&quot;Java&quot;);        //构造方法转换        String string = new String(buffer);        System.out.println(&quot;string:&quot;+string);        //toSting()方法        //通过toString方法        String  string2 = buffer.toString();        System.out.println(&quot;string2 : &quot;+string2);    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;String转StringBuffer、StringBuffer转String各有两种方法&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://seven1011.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https://seven1011.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>《剑指offer》解题答案(持续更新)</title>
    <link href="https://seven1011.github.io/2020/01/03/%E5%89%91%E6%8C%87offer%E8%A7%A3%E9%A2%98%E7%AD%94%E6%A1%88-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"/>
    <id>https://seven1011.github.io/2020/01/03/剑指offer解题答案-持续更新/</id>
    <published>2020-01-03T10:11:04.000Z</published>
    <updated>2020-02-14T07:48:11.332Z</updated>
    
    <content type="html"><![CDATA[<pre><code>把自己学习算法的过程以及思考记录下来，与大家一起分享讨论。</code></pre><a id="more"></a><br><p>(<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">牛客网</a>有相应的题目可供大家练习)</p><h2 id="1-数组中有重复的数字"><a href="#1-数组中有重复的数字" class="headerlink" title="1.数组中有重复的数字"></a>1.数组中有重复的数字</h2><p><strong>题目描述：</strong><br>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。<br><br></p><p><strong>思路一：</strong><br>通过两个for循环进行遍历，分别取出第一、第二..个元素，然后依次与后面的元素进行比较找出相同的值。<br><strong>代码：</strong></p><pre><code>public boolean duplicate(int[] nums,int length,int [] duplication) {    if(nums==null || nums.length &lt;= 0 )        return false;    for (int i = 0; i &lt; nums.length; i++) {        int num1 = nums[i];        for (int j =i+1; j &lt; nums.length; j++) {            int num2 = nums[j];            if (num1 == num2) {                duplication[0] = num1;                return true;            }        }    }    return false;}</code></pre><p><strong>思路二：</strong><br>把值等于i的元素放在i的位置上，如果i位置上已经有值为i的元素，则说明值相等。<br><strong>代码：</strong></p><pre><code>public boolean duplicate(int[] nums, int length, int[] duplication) {    if (nums == null || length &lt;= 0)        return false;    for (int i = 0; i &lt; length; i++) {        while (nums[i] != i) {            if (nums[i] == nums[nums[i]]) {                duplication[0] = nums[i];                return true;            }            swap(nums, i, nums[i]);        }    }    return false;}private void swap(int[] nums, int i, int j) {    int t = nums[i];    nums[i] = nums[j];    nums[j] = t;}</code></pre><br><h2 id="2-二维数组中查找"><a href="#2-二维数组中查找" class="headerlink" title="2.二维数组中查找"></a>2.二维数组中查找</h2><p><strong>题目描述:</strong><br>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。<br><br></p><p><strong>思路一：</strong><br>通过两个for循环，<code>array.length 获取行数；array[0].length获取列数。</code>挨个循环得到想要查找的元素，然后返回。<br><strong>代码：</strong></p><pre><code>public class Solution1 {       public boolean Find(int target, int [][] array) {           for(int i=0;i&lt;array.length;i++){               for(int j=0;j&lt;array[0].length;j++){                   if (target==array[i][j]){                       return true;                   }               }           }           return false;       }   }</code></pre><p><strong>思路二：</strong><br>从最右上角开始查找，如果得到的数比要查找的元素大，则行数减去1（去查找小的数字）；如果得到的数比目标元素小，则行数加1（去查找大的数字）。以此来查找目标元素。</p><p><strong>代码：</strong></p><pre><code>public class Solution {    public boolean Find(int target, int [][] array) {        if( array == null || array.length == 0 || array[0].length == 0)            return false;        int r = 0;        int c = array[0].length-1;        while(r &lt;= array.length-1 &amp;&amp; c &gt;= 0){            if(target == array[r][c]){                return true;            } else if(target &gt; array[r][c]){                r++;            } else if(target &lt; array[r][c]){                c--;            }        }          return false;    }}</code></pre><br><h2 id="3-空格替换"><a href="#3-空格替换" class="headerlink" title="3.空格替换"></a>3.空格替换</h2><p><strong>题目描述:</strong><br>请实现一个函数，将一个字符串中的每个空格替成“%20”例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。<br><br></p><p><strong>思路:</strong><br>遍历对象，找出<code>&quot; &quot;</code>所在的索引i，利用StringBuffer的replace(int i,int end, char cha);方法替换为<code>&quot;%20&quot;</code>，打印即可。（<a href="https://seven1011.gitee.io/2020/01/04/StringBuffer%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/#more" target="_blank" rel="noopener">《StringBuffer 的一些常用的方法总结》</a>、<a href="https://seven1011.gitee.io/2020/01/04/StringBuffer%E5%92%8CString%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/#more" target="_blank" rel="noopener">《StringBuffer与String的相互转换》</a>）</p><p><strong>代码:</strong></p><pre><code>public static String replaceSpace(StringBuffer str) {    StringBuffer str2 = new StringBuffer();    int n1 = str.capacity();    for (int i = 0; i &lt;= str.length()-1; i++) {        char n2 = str.charAt(i);        if (n2 == &apos; &apos;) {            str2 = str.replace(i, i+1, &quot;%20&quot;);        }         str2=str;    }    String result = str2.toString();    return result;}</code></pre> <br><h2 id="4-从尾到头打印链表"><a href="#4-从尾到头打印链表" class="headerlink" title="4.从尾到头打印链表"></a>4.从尾到头打印链表</h2><p><strong>题目描述:</strong><br>输入一个链表，按链表从尾到头的顺序返回一ArrayList。<br><br></p><p><strong>思路一:</strong><br>使用递归函数进行操作，每次递归会将函数放进函数栈，也是”后进先出”的思想。<br><strong>代码：</strong></p><pre><code>public class Solution {    public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) {        ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();        if(listNode != null){            list.addAll(printListFromTailToHead(listNode.next));            list.add(listNode.val);        }        return list;    }</code></pre><p><strong>思路二:</strong><br>利用ArrayList的add(int site,int val)方法（如果该位置存在元素，那么原本存在的元素自动往后退一位），每次将链表中的数据放在list的第一个位置，打印list即可得到逆序排列的链表。<br><strong>代码:</strong></p><pre><code>public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) {       ArrayList&lt;Integer&gt; list=new ArrayList&lt;&gt;();       while(listNode!=null){           list.add(0,listNode.val);           listNode=listNode.next;       }       return list;   }</code></pre><p><strong>思路三:</strong><br>利用栈的”先进后出”的特性，将数据存放进栈中，然后再取出打印(做题时用到了 <code>java.util.Stack</code> 包，需要手动导入 )。<br><strong>代码:</strong></p><pre><code>   public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) {    Stack&lt;Integer&gt; sta=new Stack&lt;&gt;();    while(listNode != null){        sta.add(listNode.val);        listNode=listNode.next;    }    ArrayList&lt;Integer&gt; list=new ArrayList&lt;&gt;();    while(!sta.empty()){        list.add(sta.pop());    }    return list;}    </code></pre><br><h2 id="5-重建二叉树"><a href="#5-重建二叉树" class="headerlink" title="5.重建二叉树"></a>5.重建二叉树</h2><p><strong>题目描述：</strong><br>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。<br><br></p><p><strong>思路一：</strong><br>前序遍历的第一个值就为二叉树的根节点，然后根据该根节点将中序遍历分为左部分和右部分，做部分就是左子树的值，有部分就是右子树的值。然后再次在前序遍历中找值然后再中序遍历中进行分块，以此进行递归操作就可以重建二叉树。</p><p><strong>代码：</strong></p><pre><code>/** * Definition for binary tree * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */public class Solution {    public TreeNode reConstructBinaryTree(int [] pre,int [] in) {        TreeNode tre=constructTree(pre,0,pre.length-1,in,0,in.length-1);        return tre;    }    public TreeNode constructTree(int[] pre,int startpre,int endpre,int[] in,int startin,int endin){        if(startpre &gt; endpre || startin &gt; endin){            return null;        }        TreeNode node = new TreeNode(pre[startpre]);        for(int i=startin; i&lt;= endin; i++){            if(in[i] == pre[startpre]){                node.left = constructTree(pre,startpre+1,startpre+i-startin,in,startin,i-1);                node.right = constructTree(pre,startpre+i-startin+1,endpre,in,i+1,endin);                break;            }        }        return node;    }}  </code></pre><br><h2 id="6-二叉树的下一个节点"><a href="#6-二叉树的下一个节点" class="headerlink" title="6.二叉树的下一个节点"></a>6.二叉树的下一个节点</h2><p> <strong>题目描述：</strong><br>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。<strong>注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</strong><br><br></p><p><strong>思路一：</strong><br>  <strong>中序遍历：左子树—&gt; 根结点 —&gt; 右子树<br>    简记：左根右</strong><br><br></p><p>根据中序遍历的特点，若二叉树不为空，则某一个节点的下一个节点大致可以分为以下两种情况：</p><p>&#160;&#160;1. 右孩子不为空，那么它的下一个节点就是右子树的最左的一个节点。<br>&#160;&#160;2. 右孩子为空<br>    &#160;&#160;(1) 该节点是父节点的左孩子，那么父节点就是下一个节点。<br>    &#160;&#160;(2) 若为右孩子，那么需要找到父节点的父节点一直向上遍历找到根节点，返回。</p><p><strong>代码：</strong></p><pre><code>/*public class TreeLinkNode {    int val;    TreeLinkNode left = null;    TreeLinkNode right = null;    TreeLinkNode next = null;    TreeLinkNode(int val) {        this.val = val;    }}*/public class Solution {    public TreeLinkNode GetNext(TreeLinkNode pNode)    {       if(pNode == null){           return null;       }        TreeLinkNode targe = null;        if(pNode.right != null){            targe = pNode.right;            while(targe.left != null){                targe = targe.left;            }            return targe;        } else{            while(pNode.next != null){               TreeLinkNode parent = pNode.next;                if(parent.left == pNode){                    return parent;                }                pNode = pNode.next;            }        }        return null;    }}</code></pre><br><h2 id="7-用两个栈实现队列"><a href="#7-用两个栈实现队列" class="headerlink" title="7.用两个栈实现队列"></a>7.用两个栈实现队列</h2><p><strong>题目描述：</strong><br>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。<br><br></p><p><strong>思路一：</strong><br>原&#160;&#160;始：1–&gt;2–&gt;3<br>存入栈1：3–&gt;2–&gt;1<br>存入栈2：1–&gt;2–&gt;3<br>取&#160;&#160;出：1–&gt;2–&gt;3<br><strong>代码：</strong></p><pre><code>import java.util.Stack;public class Solution {    Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;();    Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;();public void push(int node) {    stack1.push(node);}public int pop() throws Exception{    if(stack2.isEmpty()){        while(!stack1.isEmpty()){            stack2.push(stack1.pop());        }    }    if(stack2.isEmpty()){        throw new Exception(&quot;stack2 is empty...&quot;);    }    return stack2.pop();    }}</code></pre><br><h2 id="8-旋转数组的最小数字"><a href="#8-旋转数组的最小数字" class="headerlink" title="8.旋转数组的最小数字"></a>8.旋转数组的最小数字</h2><p><strong>题目描述：</strong><br>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3,4,5,1,2}{1,2,3,4,5}的一个旋转，该数组的最小值为1。NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。<br><br></p><p><strong>思路一：</strong><br>二分法查找，如果数组为0，则返回0。否则取start、mid、end、三个索引，从中间开始查找，若中间值大于开始的值，因为为非递减，则最小值一定出现在<code>[mid-end]</code>之间，则start=mid，mid再次取中间值。如果中间值小于最后一个值，那么最小值一定在<code>[start-mid]</code>之间，取end=mid，mid取中间值，进行循环。即可得到最小值。</p><p><strong>代码：</strong></p><pre><code>import java.util.ArrayList;public class Solution {    public int minNumberInRotateArray(int [] array) {        int n = array.length;     if(n == 0)         return 0;     int start = 0;     int end = array.length-1;     int mid =0;     while(start+1 != end){         mid = (start+end)/2;         if(array[mid] &gt; array[start]){             start = mid;         }else if(array[mid] &lt; array[end]){             end = mid;         }else {             start++;         }     }      return array[end];    }}</code></pre><br><h2 id="9-斐波那契数列"><a href="#9-斐波那契数列" class="headerlink" title="9.斐波那契数列"></a>9.斐波那契数列</h2><p><strong>题目描述：</strong><br>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。        <strong>n&lt;=39</strong><br><br></p><p><strong>思路一：</strong><br>斐波那契数列的一个重要的特点是:<br>    1.当n=1时，f(n)=1;&#160;&#160;&#160;n=0时，f(n)=0<br>    2.前面的两个数相加的和等于后面一个数字，所以第n个数字f(n)等于f(n-1)加上f(n-2),依次类推。</p><p><strong>代码：</strong></p><pre><code>public class Solution {    public int Fibonacci(int n) {    if(n&lt;2)    return n==0?0:1;    int result = Fibonacci(n-1)+Fibonacci(n-2);    return result;    }}</code></pre><br><h2 id="10-跳台阶"><a href="#10-跳台阶" class="headerlink" title="10.跳台阶"></a>10.跳台阶</h2><p><strong>题目描述：</strong><br>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。<br><br></p><p><strong>思路一：</strong><br>参考上一题斐波那契或者说递归的思想，青蛙条第一个台阶的跳法只有1种，跳两个台阶有2种。跳三个台阶，分为跳一个台阶和跳两个台阶的情况。<br><strong>代码：</strong></p><pre><code>public class Solution {    public int JumpFloor(int target) {    if(target &lt; 2)        return target;    int result = JumpFloor(n-1)+JumpFloor(n+1);    return result;</code></pre><br><h2 id="11-变态跳台阶"><a href="#11-变态跳台阶" class="headerlink" title="11.变态跳台阶"></a>11.变态跳台阶</h2><p><strong>题目描述：</strong><br>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。<br><br></p><p><strong>思路一：</strong><br>一个台阶有1中跳法、两个台阶2种跳法、三个台阶4种跳法….可以看到是一个等比数列<br><strong>代码：</strong></p><pre><code>public class Solution {    public int JumpFloorII(int target) {        if(target &lt;= 0)            return 0;        int result = (int) Math.pow(2,target-1);        return result;        }    }</code></pre><br><h2 id="12-矩阵覆盖"><a href="#12-矩阵覆盖" class="headerlink" title="12.矩阵覆盖"></a>12.矩阵覆盖</h2><p><strong>题目描述：</strong><br>我们可以用<code>2*1</code>的小矩形横着或者竖着去覆盖更大的矩形。请问用n个<code>2*1</code>的小矩形无重叠地覆盖一个<code>2*n</code>的大矩形，总共有多少种方法？<br><br></p><p><strong>思路一：</strong><br>当n=1的时候，有1种方法、当n=2的时候，有2种方法、当n=3的时候可以把<code>2*3</code>的矩形分为<code>2*1</code>和<code>2*2</code>的，所以依次类推，可以得到n时的覆盖方法的种类。<br><strong>代码：</strong></p><pre><code>public class Solution {    public int RectCover(int target) {    if(target &lt;= 2)        return target;    int result = RectCover(n-1)+RectCover(n+1);    return result;</code></pre><h2 id="13-二进制中1的个数"><a href="#13-二进制中1的个数" class="headerlink" title="13.二进制中1的个数"></a>13.二进制中1的个数</h2><p><strong>题目描述：</strong><br>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。<br><br></p><p><strong>思路一：</strong><br>Integer.bitCount();  </p><p>算法思路：先每两位瓯子统计二进制中的<em>1</em>，然后每四位一组统计<em>1</em>，接着是8位、16位和32位，最终在遇<code>0x3f</code>作与运算，输出结果。<br><strong>代码：</strong></p><pre><code>public class Solution {    public int NumberOf1(int n) {        return Integer.bitCount(n);    }}  </code></pre><p><strong>思路二：</strong><br>利用<code>n&amp;(n-1)</code>可以去除n的位级表示中最低的哪一位<br>示例： </p><pre><code>n       : 10110100n-1     : 10110011n&amp;(n-1) : 10110000 </code></pre><p><strong>代码：</strong></p><pre><code>public class Solution {    public int NumberOf1(int n) {           int c = 0;        while(n!=0){            c++;            n&amp;=(n-1);        }        return c;    }}</code></pre><h2 id="14-数值的整数次方"><a href="#14-数值的整数次方" class="headerlink" title="14.数值的整数次方"></a>14.数值的整数次方</h2><p><strong>题目描述：</strong><br>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。<br>保证base和exponent不同时为0<br><br></p><p><strong>思路一：</strong><br>利用Math.pow()函数进行计算。<br><strong>代码：</strong></p><pre><code>public class Solution {    public double Power(double base, int exponent) {        return Math.pow(base,exponent);  }}</code></pre><h2 id="15-调整数组顺序使奇数位于偶数前面"><a href="#15-调整数组顺序使奇数位于偶数前面" class="headerlink" title="15.调整数组顺序使奇数位于偶数前面"></a>15.调整数组顺序使奇数位于偶数前面</h2><p><strong>题目描述：</strong><br>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，<strong>并保证奇数和奇数，偶数和偶数之间的相对位置不变。</strong><br><br></p><p><strong>思路一：</strong><br>使用冒泡的思想，遍历数组每次都把偶数放在当前数组的最右边。<br><strong>代码：</strong></p><pre><code>  public class Solution {    public void reOrderArray(int [] array) {        int N = array.length-1;        for(int i=N ; i &gt; 0 ; i--){            for(int j = 0; j &lt; i; j++){                if(judgeO(array[j]) &amp;&amp; !judgeO(array[j+1])){                    swap(array,j,j+1);                }            }        }    }public boolean judgeO(int x){    return x%2 == 0;}public void swap(int[] num ,int a, int b){    int c=num[a];    num[a] = num[b];    num[b] = c;}</code></pre><p>}</p><h2 id="16-链表中倒数第k个结点"><a href="#16-链表中倒数第k个结点" class="headerlink" title="16.链表中倒数第k个结点"></a>16.链表中倒数第k个结点</h2><p><strong>题目描述：</strong><br>输入一个链表，输出该链表中倒数第k个结点。<br><br></p><p><strong>思路一：</strong><br>双指针，首先先让指针P1移动到第K个节点处，然后指针P2指向头结点，P1和P2同时移动，可知当P1移动到结尾处时候，P2移动到倒数第K个节点处。<br><strong>代码：</strong></p><pre><code>    /*public class ListNode {    int val;    ListNode next = null;    ListNode(int val) {        this.val = val;    }}*/public class Solution {    public ListNode FindKthToTail(ListNode head,int k) {        if(head == null || k == 0){            return null;        }        ListNode p1 = head;        while(p1 != null &amp;&amp; k-- &gt; 0){            p1 = p1.next;        }        if(k &gt; 0)            return null;        ListNode p2 = head;        while(p1!= null){            p2 = p2.next;            p1 = p1.next;        }        return p2;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;把自己学习算法的过程以及思考记录下来，与大家一起分享讨论。&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://seven1011.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://seven1011.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Git常用命令</title>
    <link href="https://seven1011.github.io/2019/12/28/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://seven1011.github.io/2019/12/28/Git常用命令/</id>
    <published>2019-12-27T16:29:47.000Z</published>
    <updated>2020-01-02T00:36:52.255Z</updated>
    
    <content type="html"><![CDATA[<pre><code>【介绍】MySQL多表和事物知识点总结</code></pre><a id="more"></a><br><h2 id="工作原理："><a href="#工作原理：" class="headerlink" title="工作原理："></a>工作原理：</h2><p><img src="/images/picture/20191227165200.png" alt><br><br></p><p><strong>名词解释：</strong><br><img src="/images/picture/20191227165211.png" alt></p><br><h2 id="常用命令："><a href="#常用命令：" class="headerlink" title="常用命令："></a>常用命令：</h2><h2 id="创建："><a href="#创建：" class="headerlink" title="创建："></a><strong>创建：</strong></h2><br><p><strong>1. 创建一个新的本地仓库</strong></p><pre><code>git init</code></pre><p><strong>2. 克隆</strong></p><pre><code>git clone [url]</code></pre><br><h2 id="分支："><a href="#分支：" class="headerlink" title="分支："></a><strong>分支：</strong></h2><br><p><strong>1. 创建分支</strong></p><pre><code>git branch develop</code></pre><p><strong>2. 查看本地分支 （字体颜色变绿，前面带有’*’号的是当前使用的分支）</strong></p><pre><code>git branch</code></pre><p><strong>3. 查看远程分支（远程分支会用红色表示出来）</strong></p><pre><code>git branch -r</code></pre><p><strong>4. 查看所有分支</strong></p><pre><code>git branch -a</code></pre><p><strong>5. 切换分支</strong></p><pre><code>git checkout</code></pre><p><strong>6. 切换到上一个分区</strong></p><pre><code>git checkout -</code></pre><p><strong>7. 新建一个分支并于指定的远程分支建立追踪关系</strong></p><pre><code>git branch   --track [local-branch]  [remote-branch]</code></pre><p><strong>8. 修改追踪关系</strong><br>   <code>1. 切换分支 git checkout [local-branch]    2. 修改追踪仓库 git branch  --set-upstream-to  [remote-branch]</code></p><p><strong>ps: 也可以在初次push的时候 加上-u参数</strong></p><pre><code>git push -u [remote-branch]</code></pre><p><strong>9. 删除分支</strong></p><pre><code>git branch -d [branch]</code></pre><p><strong>10. 删除远程分支</strong></p><pre><code>git push origin -delete [branch]git branch -dr [remote-branch]</code></pre><br><h2 id="变化："><a href="#变化：" class="headerlink" title="变化："></a><strong>变化：</strong></h2><br><p><strong>1. 比较两次修改的差异</strong></p><pre><code>git diff</code></pre><p><strong>2. 查看当前的工作目录和暂存区的状态</strong></p><pre><code>git status</code></pre><br><h2 id="添加、删除、提交："><a href="#添加、删除、提交：" class="headerlink" title="添加、删除、提交："></a><strong>添加、删除、提交：</strong></h2><br><p><strong>1. 添加指定文件到暂存区</strong></p><pre><code>git add [file1] [file2]</code></pre><p><strong>2. 添加所有文件到暂存区</strong></p><pre><code>git add .</code></pre><p><strong>3. 添加指定目录以及子目录到暂存区</strong></p><pre><code>git add [dir]</code></pre><p><strong>4. 提交暂存区代码到仓库区</strong></p><pre><code>git commit -m [备注]</code></pre><p><strong>5. 提交指定文件到仓库区</strong></p><pre><code>git commmit [file1] [file2] ... -m [message]</code></pre><p><strong>6. 对上一次提交进行修改</strong></p><pre><code>git commit --amend  </code></pre><p><strong>7. 删除暂存区或者分支上的文件，同时工作区也不需要该文件</strong></p><pre><code>git rm [file]  (git rm=rm+git add)</code></pre><p><strong>8. 删除暂存区或分支上的文件，但本地继续使用，且不希望该文件被版本控制</strong></p><pre><code>git rm --cached [file]</code></pre><br><h2 id="同步："><a href="#同步：" class="headerlink" title="同步："></a><strong>同步：</strong></h2><br><p><strong>1. 下载远程仓库的所有变动</strong></p><pre><code>git fetch [remote]</code></pre><p><strong>2. 显示所有的远程仓库</strong></p><pre><code>git remote -v</code></pre><p><strong>3. 将远程仓库的代码拉取下来与本地进行合并</strong></p><pre><code>git pull [remote-branch]</code></pre><p><strong>4. 上传本地指定分支到远程仓库</strong></p><pre><code>git push [remote-branch]</code></pre><br><h2 id="版本、撤销："><a href="#版本、撤销：" class="headerlink" title="版本、撤销："></a><strong>版本、撤销：</strong></h2><br><p><strong>1. 显示当前分支版本的历史</strong></p><pre><code>git log</code></pre><p><strong>2. 显示指定文件的每一次变化</strong></p><pre><code>git log -p [file]</code></pre><p><strong>3. 显示指定文件在什么时间被怎样修改</strong></p><pre><code>git blame [file]</code></pre><p><strong>4. 恢复暂存区的指定文件到工作区</strong></p><pre><code>git checkout [file]</code></pre><p><strong>5. 恢复暂存区的所有文件到工作区</strong></p><pre><code>git checkout .</code></pre><p><strong>6. 重做工作区与暂存区，与上一次commit保持一致</strong></p><pre><code>git reset  —hard</code></pre><hr><p>参考文章：&#160;&#160;<a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank" rel="noopener">http://www.ruanyifeng.com</a>     &#160;&#160;&#160;&#160;&#160;      <a href="https://gitee.com/liaoxuefeng/learn-java/raw/master/teach/git-cheatsheet.pdf" target="_blank" rel="noopener">英文PDF下载地址</a></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;【介绍】MySQL多表和事物知识点总结&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="Git" scheme="https://seven1011.github.io/categories/Git/"/>
    
    
      <category term="Git" scheme="https://seven1011.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Mybatis逆向工程中生成的Example类详细介绍</title>
    <link href="https://seven1011.github.io/2019/12/05/Mybatis%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E4%B8%AD%E7%94%9F%E6%88%90%E7%9A%84Example%E7%B1%BB%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D/"/>
    <id>https://seven1011.github.io/2019/12/05/Mybatis逆向工程中生成的Example类详细介绍/</id>
    <published>2019-12-04T18:46:41.000Z</published>
    <updated>2019-12-27T08:32:10.844Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/picture/mybatis.png" alt></p><a id="more"></a><h2 id="1-内容介绍"><a href="#1-内容介绍" class="headerlink" title="1. 内容介绍"></a>1. 内容介绍</h2><p>Example类主要是用来对查询进行添加条件的。Model类只能进行简单的查询操作，如果想要自己加一些查询的条件，可以使用Example类。<br><br></p><p><strong>关于类中定义的三个变量如图所示：</strong></p><p><img src="/images/picture/20191204185823.png" alt><br><br></p><p>根据名字可以很容易理解：</p><p><strong>orderByClause：</strong>主要进行ORDER BY条件（升序：asc  降序：desc）</p><p><strong>distinct：</strong>主要是用来指定DISTINCT查询的。（DISTINCT可以为从表中某字段中选取出唯一不同的值）</p><p><strong>oredCriteria：</strong>主要用于自定义查询条件<br><br></p><p><strong>Example中的一些内部类：</strong></p><p><img src="/images/picture/20191204192217.png" alt><br><br></p><p><strong>Criteria：</strong> GeneratedCriteria的子类，我们进行构造查询就是利用这个类中的方法。</p><p><strong>Cretiron：</strong>最底层的where条件，主要用于字段级别的一些条件查询。例如：id=5</p><p><strong>GeneratedCriteria：</strong>里面是字段的一些方法，他保存一组Cretiron对象。<br><br></p><p>这是关于Example类的一些主要的内容。</p><h2 id="2-方法介绍"><a href="#2-方法介绍" class="headerlink" title="2. 方法介绍"></a>2. 方法介绍</h2><table><thead><tr><th align="center"><strong>方法</strong></th><th align="center"><strong>说明</strong></th></tr></thead><tbody><tr><td align="center">example.setOrderByClause(“字段名 ASC”);</td><td align="center">添加升序排列条件，DESC为降序</td></tr><tr><td align="center">example.setDistinct(false)</td><td align="center">去除重复，boolean型，true为选择不重复的记录。</td></tr><tr><td align="center">criteria.andXxxIsNull</td><td align="center">添加字段xxx为null的条件</td></tr><tr><td align="center">criteria.andXxxIsNotNull</td><td align="center">添加字段xxx不为null的条件</td></tr><tr><td align="center">criteria.andXxxEqualTo(value)</td><td align="center">添加xxx字段等于value条件</td></tr><tr><td align="center">criteria.andXxxNotEqualTo(value)</td><td align="center">添加xxx字段不等于value条件</td></tr><tr><td align="center">criteria.andXxxGreaterThan(value)</td><td align="center">添加xxx字段大于value条件</td></tr><tr><td align="center">criteria.andXxxGreaterThanOrEqualTo(value)</td><td align="center">添加xxx字段大于等于value条件</td></tr><tr><td align="center">criteria.andXxxLessThan(value)</td><td align="center">添加xxx字段小于value条件</td></tr><tr><td align="center">criteria.andXxxLessThanOrEqualTo(value)</td><td align="center">添加xxx字段小于等于value条件</td></tr><tr><td align="center">criteria.andXxxIn(List&lt;？&gt;)</td><td align="center">添加xxx字段值在List&lt;？&gt;条件</td></tr><tr><td align="center">criteria.andXxxNotIn(List&lt;？&gt;)</td><td align="center">添加xxx字段值不在List&lt;？&gt;条件</td></tr><tr><td align="center">criteria.andXxxLike(“%”+value+”%”)</td><td align="center">添加xxx字段值为value的模糊查询条件</td></tr><tr><td align="center">criteria.andXxxNotLike(“%”+value+”%”)</td><td align="center">添加xxx字段值不为value的模糊查询条件</td></tr><tr><td align="center">criteria.andXxxBetween(value1,value2)</td><td align="center">添加xxx字段值在value1和value2之间条件</td></tr><tr><td align="center">criteria.andXxxNotBetween(value1,value2)</td><td align="center">添加xxx字段值不在value1和value2之间条件</td></tr><tr><td align="center"><br></td><td align="center"></td></tr></tbody></table><p>关于一些具体用法参考第二篇参考文章</p><hr><p><strong>参考文章:</strong> &emsp;<a href="https://blog.csdn.net/Nerver_77/article/details/79707190" target="_blank" rel="noopener">《Mybatis逆向工程中生成的Example类》</a>&emsp;&emsp;<a href="https://blog.csdn.net/biandous/article/details/65630783" target="_blank" rel="noopener">《MyBatis的Mapper接口以及Example的实例函数及详解》</a></p><hr><br>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/picture/mybatis.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Mybatis" scheme="https://seven1011.github.io/categories/Mybatis/"/>
    
    
      <category term="Mybatis" scheme="https://seven1011.github.io/tags/Mybatis/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis 逆向工程介绍</title>
    <link href="https://seven1011.github.io/2019/12/04/MyBatis-%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E4%BB%8B%E7%BB%8D/"/>
    <id>https://seven1011.github.io/2019/12/04/MyBatis-逆向工程介绍/</id>
    <published>2019-12-04T15:05:43.000Z</published>
    <updated>2019-12-27T08:32:05.956Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/picture/mybatis.png" alt></p><a id="more"></a><h2 id="1-概念："><a href="#1-概念：" class="headerlink" title="1. 概念："></a>1. 概念：</h2><br><p>逆向工程就是根据数据库中对应的表在项目工程中生成相应的MyBatis代码（XXXMapper.java/XXXMapper.xml/Moudle(XXX)）,逆向工程生成的代码可以进行简单的数据库操作，能够节省不少的时间，MyBatis官方提供了相应的代码，所以在实际中运用较多。<br><br></p><h2 id="2-操作配置"><a href="#2-操作配置" class="headerlink" title="2. 操作配置"></a>2. 操作配置</h2><br><p><strong>1. 下载相应的jar包，主要有两个：</strong></p><p><img src="/images/picture/20191204152303.png" alt></p><p>&emsp;&emsp;<strong>下载链接(文章结尾附有完整项目代码)：</strong><a href="//download.csdn.net/download/weixin_45910396/12013449">//download.csdn.net/download/weixin_45910396/12013449</a><br><br></p><p><strong>2. 项目目录：</strong></p><p><img src="/images/picture/20191204152415.png" alt></p><br><p><strong>3. main方法：</strong></p><p>导入jar之后编写核心代码：<a href="http://mybatis.org/generator/running/runningWithJava.html" target="_blank" rel="noopener">打开网址</a></p><p><img src="/images/picture/20191204110.png" alt></p><br><p>代码如下：</p><pre><code>public static void main(String[] args)throws Exception {        List&lt;String&gt; warnings = new ArrayList&lt;String&gt;();        boolean overwrite = true;        File configFile = new File(&quot;src/generator.xml&quot;);        ConfigurationParser cp = new ConfigurationParser(warnings);        Configuration config = cp.parseConfiguration(configFile);        DefaultShellCallback callback = new DefaultShellCallback(overwrite);        MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config,                callback, warnings);        myBatisGenerator.generate(null);    }</code></pre><br><p><strong>4. generator.xml配置文件</strong></p><p>同样的网址，打开 <code>XML Configuration  Reference</code></p><p><img src="/images/picture/20191204153813.png" alt></p><br><p>我的代码如下：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE generatorConfiguration        PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;&lt;generatorConfiguration&gt;    &lt;context id=&quot;mysqlTables&quot; targetRuntime=&quot;MyBatis3&quot;&gt;        &lt;!--数据库配置--&gt;        &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot;                        connectionURL=&quot;jdbc:mysql://localhost:3306/test&quot;                        userId=&quot;root&quot;                        password=&quot;root0809&quot;&gt;        &lt;/jdbcConnection&gt;        &lt;!-- java类型解析 --&gt;        &lt;javaTypeResolver &gt;            &lt;property name=&quot;forceBigDecimals&quot; value=&quot;false&quot; /&gt;        &lt;/javaTypeResolver&gt;        &lt;!-- 模型生成包名--&gt;        &lt;javaModelGenerator targetPackage=&quot;com.seven.model&quot; targetProject=&quot;.\src&quot;&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt;            &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&gt;        &lt;/javaModelGenerator&gt;        &lt;!-- mybatis的映射.xml--&gt;        &lt;sqlMapGenerator targetPackage=&quot;com.seven.mapper&quot; targetProject=&quot;.\src&quot;&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt;        &lt;/sqlMapGenerator&gt;        &lt;!-- mybatis 的mapper接口生成的包路径--&gt;        &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.seven.mapper&quot; targetProject=&quot;.\src&quot;&gt;            &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt;        &lt;/javaClientGenerator&gt;        &lt;!-- 配置生成表的模型--&gt;        &lt;table tableName=&quot;rs&quot; domainObjectName=&quot;Rs&quot;/&gt;        &lt;table tableName=&quot;pollutiontrend&quot; domainObjectName=&quot;PollutionTrend&quot;/&gt;    &lt;/context&gt;&lt;/generatorConfiguration&gt;</code></pre><p>至此，MyBatis逆向工程的所有配置都已经完成了，运行main方法即可得到对应的model和mapper以及mapper.xml文件。<br><br></p><p>&emsp;&emsp;<strong>附上完整的项目代码，直接下载即可使用：</strong><a href="//download.csdn.net/download/weixin_45910396/12013612">//download.csdn.net/download/weixin_45910396/12013612</a><br><br></p><p>运行MyBatis 逆向工程，发现在model文件夹下生成了XXXExample类，关于Example类的详细介绍可以参考另一篇文章<a href="https://seven1011.gitee.io/2019/12/05/Mybatis%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E4%B8%AD%E7%94%9F%E6%88%90%E7%9A%84Example%E7%B1%BB%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D/#" target="_blank" rel="noopener">《Mybatis逆向工程中生成的Example类详细介绍》</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/picture/mybatis.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Mybatis" scheme="https://seven1011.github.io/categories/Mybatis/"/>
    
    
      <category term="Mybatis" scheme="https://seven1011.github.io/tags/Mybatis/"/>
    
  </entry>
  
  <entry>
    <title>JavaType和ofType区别简单介绍</title>
    <link href="https://seven1011.github.io/2019/11/09/MMyBatis-%E5%A4%9A%E5%AF%B9%E5%A4%9A%E6%98%A0%E5%B0%84/"/>
    <id>https://seven1011.github.io/2019/11/09/MMyBatis-多对多映射/</id>
    <published>2019-11-08T21:14:39.000Z</published>
    <updated>2019-11-09T12:54:58.348Z</updated>
    
    <content type="html"><![CDATA[<pre><code>JavaType和ofType区别讲解以及BuilderException报错解决。</code></pre><a id="more"></a><h3 id="JavaType和ofType简单介绍："><a href="#JavaType和ofType简单介绍：" class="headerlink" title="JavaType和ofType简单介绍："></a>JavaType和ofType简单介绍：</h3><p>JavaType和ofType都是用来指定对象类型的但是JavaType是用来指定pojo中属性的类型，而ofType指定的是映射到list集合属性中pojo的类型的。<br><br></p><p>或者简单一点理解就是：<strong>ofType一半指定的是集合的泛型的类型，而javaType一般指的是变量的属性类型</strong>。</p><p>再多对多的映射关系中，配置文件中没有写入<code>javaType</code>属性，即错误代码如下：</p><p><img src="/images/picture/2019.11.8.png" alt></p><p><strong>运行时映射器会引发异常：</strong></p><p><code>Cause: org.apache.ibatis.builder.BuilderException: Ambiguous collection type for property &#39;orderDetails&#39;. Please add &#39;resultType&#39; or &#39;resultMap&#39;.</code></p><p>查看<a href="https://github.com/mybatis/mybatis-3/wiki/FAQ#how-do-i-map-a-list-of-simple-type-objects-string-integer-etc-to-a-bean-or-map-" target="_blank" rel="noopener">官方文档</a>，其实对此已经进行了说明，只需要在 <code>collection</code>里面添加<code>javaType</code>即可<br><br></p><p>重新运行，显示成功。<br><br></p><p><strong>官方的说明一定要大致的浏览一下，会在写代码时省去很多麻烦….</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;JavaType和ofType区别讲解以及BuilderException报错解决。&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="MyBatis" scheme="https://seven1011.github.io/categories/MyBatis/"/>
    
    
      <category term="JavaType" scheme="https://seven1011.github.io/tags/JavaType/"/>
    
      <category term="ofType" scheme="https://seven1011.github.io/tags/ofType/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis 入门—(自学笔记)</title>
    <link href="https://seven1011.github.io/2019/11/09/MyBatis-%E5%85%A5%E9%97%A8%E2%80%94-%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/"/>
    <id>https://seven1011.github.io/2019/11/09/MyBatis-入门—-自学笔记/</id>
    <published>2019-11-08T21:13:32.000Z</published>
    <updated>2019-11-08T13:46:40.066Z</updated>
    
    <content type="html"><![CDATA[<pre><code>【介绍】MyBatis 自学笔记</code></pre><a id="more"></a><h1 id="1-MyBatis"><a href="#1-MyBatis" class="headerlink" title="1.MyBatis"></a>1.MyBatis</h1><h2 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h2><blockquote><p>MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java 的 POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</p></blockquote><p>MyBatis 本是apache的一个开源项目iBatis框架，后来经过一些改进并改名为MyBatis。它主要对jdbc操作数据库的过程进行封装。<br><br></p><p><strong>JDBC的封装框架主要有;</strong></p><p>&emsp;&emsp;Hibernate&emsp;dbutils&emsp;jdbcTemplate[spring] &emsp;mybatis<br><br></p><p><strong>原理介绍：</strong></p><p>&emsp;&emsp;Mybatis通过xml或注解的方式将要执行的各种<code>statement（statement、preparedStatemnt、CallableStatement）</code>配置起来，并通过java对象和statement中的sql进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射成java对象并返回。<br><br></p><h2 id="1-2-MyBatis的框架核心"><a href="#1-2-MyBatis的框架核心" class="headerlink" title="1.2 MyBatis的框架核心"></a>1.2 MyBatis的框架核心</h2><br><p>&emsp;&emsp;1、<strong>mybatis配置文件，</strong>包括Mybatis全局配置文件和Mybatis映射文件，其中全局配置文件配置了数据源、事务等信息；映射文件配置了SQL执行相关的信息。<br><br></p><p> &emsp;&emsp;2、  mybatis通过读取配置文件信息（全局配置文件和映射文件），<strong>构造出SqlSessionFactory，即会话工厂</strong>。<br> <br></p><p>&emsp;&emsp;3、  通过SqlSessionFactory，可以创建<strong>SqlSession</strong>即会话。<strong>Mybatis是通过SqlSession来操作数据库的</strong>。<br> <br></p><p>&emsp;&emsp;4、SqlSession本身不能直接操作数据库，它是通过底层的<strong>Executor执行器接口来操作数据库</strong>的。<strong>Executor接口有两个实现类，一个是普通执行器，一个是缓存执行器（默认）。</strong><br> <br></p><p>&emsp;&emsp;5、Executor执行器要处理的SQL信息是封装到一个底层对象<strong>MappedStatement</strong>中。该对象包括：<strong>SQL语句、输入参数映射信息、输出结果集映射信息。其中输入参数和输出结果的映射类型包括HashMap集合对象、POJO对象类型。</strong><br><br></p><h1 id="2-入门"><a href="#2-入门" class="headerlink" title="2 入门"></a>2 入门</h1><br><h3 id="2-1-简单操作流程如下："><a href="#2-1-简单操作流程如下：" class="headerlink" title="2.1 简单操作流程如下："></a>2.1 简单操作流程如下：</h3><p><img src="/images/picture/2019.11.8(2).png" alt></p><p>&emsp;&emsp;除此之外，还有个更多模糊查询用户信息、插入用户信息、删除用户、更新用户、MySQL自增主键、MySQL自增UUID等。</p><p>需要注意的属性有：</p><ul><li><strong>selectOne和selectList</strong><br>&emsp;&emsp;<strong>selectOne：</strong>只能查询0或1条记录，大于1条记录的话，会报错：</li></ul><p>&emsp;&emsp;<strong>selectList：</strong>可以查询0或N条记录</p><ul><li><strong>#{}和${}</strong></li><li><strong>parameterType和resultType</strong></li></ul><p>&emsp;&emsp;后两个详见：<a href="https://seven1011.github.io/2019/11/07/parameterType%E5%B1%9E%E6%80%A7%E4%BC%A0%E5%8F%82%E7%B1%BB%E5%9E%8B%E4%BB%8B%E7%BB%8D/#more">parameterType属性传参类型介绍</a></p><h2 id="2-2-MyBatis的Dao编写"><a href="#2-2-MyBatis的Dao编写" class="headerlink" title="2.2 MyBatis的Dao编写"></a>2.2 MyBatis的Dao编写</h2><ul><li><p><strong>传统方式</strong></p></li><li><p><strong>mapper代理方式实现</strong></p><p>  <strong>开发规范：</strong></p></li></ul><p>&emsp;&emsp;1. mapper接口的全限定名要和mapper映射文件的namespace的值相同。<br>&emsp;&emsp;2. mapper接口的方法名称要和mapper映射文件中的statement的id相同；<br>&emsp;&emsp;3. mapper接口的方法参数只能有一个，且类型要和mapper映射文件中statement的parameterType的值保持一致。<br>&emsp;&emsp;4. mapper接口的返回值类型要和mapper映射文件中statement的resultType值或resultMap中的type值保持一致；</p><h2 id="2-3-一些其他的配置"><a href="#2-3-一些其他的配置" class="headerlink" title="2.3 一些其他的配置"></a>2.3 一些其他的配置</h2><p>&emsp;&emsp;1. properties数据库文件配置<br>&emsp;&emsp;2. setting<br>&emsp;&emsp;3. 别名typeAliases（三种方式）<br>&emsp;&emsp;<strong>- mappers</strong></p><p>&emsp;&emsp;&emsp;&emsp;<code>&lt;mapper resource=&#39;&#39;/&gt;</code></p><p>&emsp;&emsp;&emsp;&emsp;<code>&lt;mapper url=&#39;&#39;/&gt; 【一般不用】</code></p><p>&emsp;&emsp;&emsp;&emsp;<code>&lt;mapper class=&#39;&#39;/&gt;</code></p><p>&emsp;&emsp;&emsp;&emsp;<code>&lt;package name=&#39;&#39;/&gt;（推荐使用）</code></p><h2 id="2-4-动态SQL"><a href="#2-4-动态SQL" class="headerlink" title="2.4 动态SQL"></a>2.4 动态SQL</h2><p>&emsp;&emsp;<strong>if和where标签</strong><br>&emsp;&emsp;<strong>SQL片断</strong><br>&emsp;&emsp;<strong>foreach标签</strong></p><h1 id="3-mybatis与hibernate的区别【面试题】"><a href="#3-mybatis与hibernate的区别【面试题】" class="headerlink" title="3 mybatis与hibernate的区别【面试题】"></a>3 mybatis与hibernate的区别【面试题】</h1><p>&emsp;&emsp;请<a href="https://blog.csdn.net/eff666/article/details/71332386" target="_blank" rel="noopener">参考这篇文章</a>…….</p><hr><p>参考：</p><p>&emsp;&emsp;<a href="https://www.jianshu.com/p/f4d3e7ddedca" target="_blank" rel="noopener">JAVAEE——Mybatis(Mybatis介绍配置使用以及与Spring整合)</a><br>&emsp;&emsp;以及自学视频的笔记</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;【介绍】MyBatis 自学笔记&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="MyBatis" scheme="https://seven1011.github.io/categories/MyBatis/"/>
    
    
      <category term="MyBatis" scheme="https://seven1011.github.io/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>parameterType属性传参类型介绍 </title>
    <link href="https://seven1011.github.io/2019/11/07/parameterType%E5%B1%9E%E6%80%A7%E4%BC%A0%E5%8F%82%E7%B1%BB%E5%9E%8B%E4%BB%8B%E7%BB%8D/"/>
    <id>https://seven1011.github.io/2019/11/07/parameterType属性传参类型介绍/</id>
    <published>2019-11-06T21:20:03.000Z</published>
    <updated>2019-11-07T02:16:18.181Z</updated>
    
    <content type="html"><![CDATA[<pre><code>parameterType属性传参类型介绍</code></pre><a id="more"></a><p>mybatis中定义sql语句 可以通过parameterType指定指定参数的类型，通过resultType指定输出参数的类型</p><p><img src="/images/picture/2019.11.6.png" alt></p><p>MyBatis可以使用的parameterType有基本数据类型和Java复杂数据类型。复杂数据类型包含Java实体类、Map等。<br><br></p><p><strong>基本数据类型：</strong>int,string,long,Date;  </p><p><strong>复杂数据类型：</strong>类和Map</p><h3 id="获取参数的值："><a href="#获取参数的值：" class="headerlink" title="获取参数的值："></a>获取参数的值：</h3><p><strong>1. 基本数据类型</strong>，可以通过#{参数名}获取参数的值（参数名可以任意填写，为阅读方便还需填写对应的参数名较好）。<br><br></p><p><strong>原因：</strong>JAVA反射只能获取方法参数的类型，不能得知方法参数的名字<br><br></p><p><strong>2. 当有多个参数需要传递时</strong>，可以使用Map，通过#{map的key来获取相应的传递的值}<br><br></p><p><strong>注意：</strong>参数传递是，sql语句和map中相应的key值要完全一样，注意区分大小写，否则会报错。<br><br></p><p><strong>3. Java实体类型</strong>，通过#{属性名}获取相应的参数的值</p><h3 id="和"><a href="#和" class="headerlink" title="#{}和${}"></a>#{}和${}</h3><p><strong>#{}：</strong>相当于预处理中的占位符？</p><pre><code>#{}里面的参数表示接收java输入参数的名称。#{}可以接受HashMap、POJO类型的参数。当接受简单类型的参数时，#{}里面可以是value，也可以是其他。</code></pre><p><strong>#{}</strong>可以防止SQL注入。</p><p><strong>${}：</strong>相当于拼接SQL串，对传入的值不做任何解释的原样输出。</p><pre><code>${}会引起SQL注入，所以要谨慎使用。${}可以接受HashMap、POJO类型的参数。当接受简单类型的参数时，${}里面只能是value。</code></pre><hr><p>参考：<a href="https://blog.csdn.net/u010235716/article/details/51698422" target="_blank" rel="noopener">MyBatis中传入参数parameterType类型详解</a></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;parameterType属性传参类型介绍&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title> TomCat新版本命令行乱码问题解决 </title>
    <link href="https://seven1011.github.io/2019/11/05/TomCat%E6%96%B0%E7%89%88%E6%9C%AC%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    <id>https://seven1011.github.io/2019/11/05/TomCat新版本命令行乱码问题解决/</id>
    <published>2019-11-04T20:56:43.000Z</published>
    <updated>2019-11-04T13:23:36.704Z</updated>
    
    <content type="html"><![CDATA[<pre><code>新版本的tomcat在命令窗口中会出现乱码情况</code></pre><a id="more"></a><br><p><img src="/images/picture/TomCat2.png" alt><br><br></p><p>新版本之后若乱码，只需要在配置文件中<code>logging.properties</code>将对应的utf-8修改为GBK即可，如下图所示：<br><br></p><p><img src="/images/picture/TomCat4.png" alt><br><br></p><p>重新启动TomCat。</p><hr><p>参考：<a href="https://bbs.csdn.net/topics/392500916" target="_blank" rel="noopener">CSDN论坛</a></p><hr><br>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;新版本的tomcat在命令窗口中会出现乱码情况&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="TomCat" scheme="https://seven1011.github.io/categories/TomCat/"/>
    
    
      <category term="TomCat" scheme="https://seven1011.github.io/tags/TomCat/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat端口修改</title>
    <link href="https://seven1011.github.io/2019/11/05/9-0-241-port-out-of-range-1/"/>
    <id>https://seven1011.github.io/2019/11/05/9-0-241-port-out-of-range-1/</id>
    <published>2019-11-04T20:56:20.000Z</published>
    <updated>2019-11-09T13:18:02.545Z</updated>
    
    <content type="html"><![CDATA[<pre><code>运行TomCat发现报错</code></pre><a id="more"></a><p><img src="/images/picture/TomCat1.png" alt></p><p>这种情况是因为端口号不能是-1；<br><br></p><p>修改：</p><p>打开TomCat配置文件<code>./confl</code>里面的server.xml检查，修改端口，一般为80，或者1-65535之间任意一个整数：<br><br></p><p><img src="/images/picture/TomCat3.png" alt></p><p>重新启动。</p><br><p>如果出现报错：<code>java.net.BindException: Address already in use: JVM_Bind</code></p><p>说明端口冲突，修改后的端口已经被占用了。需要重新进行修改：</p><p>或者可以打开cmd命令窗口，输入<code>netstat -ano</code>，可以查看端口被占用情况。</p><hr><p>参考：<a href="https://stackoverflow.com/questions/12737293/how-do-i-resolve-the-java-net-bindexception-address-already-in-use-jvm-bind" target="_blank" rel="noopener">How do I resolve the “java.net.BindException: Address already in use: JVM_Bind” error?</a></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;运行TomCat发现报错&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="TomCat" scheme="https://seven1011.github.io/categories/TomCat/"/>
    
    
      <category term="TomCat" scheme="https://seven1011.github.io/tags/TomCat/"/>
    
  </entry>
  
  <entry>
    <title>HTML&amp;CSS基础知识(三) </title>
    <link href="https://seven1011.github.io/2019/11/04/HTML-CSS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E4%B8%89/"/>
    <id>https://seven1011.github.io/2019/11/04/HTML-CSS基础知识-三/</id>
    <published>2019-11-03T22:09:49.000Z</published>
    <updated>2019-11-04T00:21:55.190Z</updated>
    
    <content type="html"><![CDATA[<pre><code>【介绍】HTML&amp;CSS必知必会，学习笔记</code></pre><a id="more"></a><h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="css：页面美化和布局控制"><a href="#css：页面美化和布局控制" class="headerlink" title="css：页面美化和布局控制"></a>css：页面美化和布局控制</h2><h3 id="1-概念："><a href="#1-概念：" class="headerlink" title="1. 概念："></a>1. 概念：</h3><pre><code>Cascading Style Sheets 层叠样式表</code></pre><h3 id="2-好处："><a href="#2-好处：" class="headerlink" title="2. 好处："></a>2. 好处：</h3><p><strong>·功能强大</strong><br><strong>·将内容的展示和样式控制分离</strong></p><pre><code>- 降低耦合度。解耦- 让分工协作更容易- 提高开发效率</code></pre><h3 id="3-css的使用：css与html的样式结合"><a href="#3-css的使用：css与html的样式结合" class="headerlink" title="3. css的使用：css与html的样式结合"></a>3. css的使用：css与html的样式结合</h3><pre><code>1. 内联样式：在标签内使用style属性指定css代码2. 内部样式：在head标签内，定义style标签，style标签的标签体就是css代码3. 外部样式：    1. 定义css资源文件    2. 在head标签内定义link标签，引入外部资源文件</code></pre><p><strong>注意：</strong>1，2，3种方式 css作用范围越来越大。第一种方式不常用,后期常用后两种</p><h3 id="4-css语法："><a href="#4-css语法：" class="headerlink" title="4. css语法："></a>4. css语法：</h3><p><strong>格式</strong></p><pre><code>选择器{属性名1:属性值1;属性名2:属性值2;}</code></pre><p><strong>选择器：</strong>筛选具有相似特征的元素</p><p>&emsp;&emsp;注意：每一对属性需要使用<code>;</code>隔开，最后一对属性可以不加<code>;</code></p><h3 id="5-选择器："><a href="#5-选择器：" class="headerlink" title="5. 选择器："></a>5. 选择器：</h3><h4 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h4><p><strong>1. 基础选择器：</strong></p><pre><code>1. id选择器：选择具体的id属性值的元素，建议在一个html页面中id值唯一    语法：#id属性值{}2. 元素选择器：选择具有相同标签名称的元素    语法：标签名称{}    注意：id选择器优先级高于元素选择器3. 类选择器    语法：.class属性指{}    注意：类选择器优先级高于元素选择器</code></pre><p><strong>2. 扩展选择器：</strong></p><pre><code>1.  选择所有元素    语法：*{}2. 并集选择器    选择器1，选择器2{}3. 子选择器：筛选选择器1下的选择器2元素    语法：选择器1  选择器2{}4. 父选择器：筛选选择器2的父元素选择器1    语法：选择器1&gt;选择器2{}5. 属性选择器：选择元素名称，属性名=属性指的元素    语法：元素名称[属性名=“属性指”]{}6. 为类选择器：选择一些元素具有的状态    语法：元素：状态{}    状态：    link：初始化的状态    visited：被访问过的状态    active：正在访问的状态    hover：鼠标悬浮的状态</code></pre><h3 id="6-属性"><a href="#6-属性" class="headerlink" title="6. 属性"></a>6. 属性</h3><p><strong>1. 字体、文本</strong></p><pre><code>font-size：字体大小color：文本颜色text-align：对齐方式line-height：行高</code></pre><p><strong>2. 背景</strong></p><pre><code>background</code></pre><p><strong>3. 边框</strong></p><pre><code>border：设置表框、符合属性</code></pre><p><strong>4. 尺寸</strong></p><pre><code>width：宽度height：高度</code></pre><p><strong>5. 盒子模型</strong></p><pre><code>margin：外边距padding：内边距默认情况下内边距会影响盒子的大小</code></pre><hr><p><strong>来源：</strong>学习笔记</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;【介绍】HTML&amp;amp;CSS必知必会，学习笔记&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="HTML" scheme="https://seven1011.github.io/categories/HTML/"/>
    
      <category term="CSS" scheme="https://seven1011.github.io/categories/HTML/CSS/"/>
    
    
      <category term="HTML" scheme="https://seven1011.github.io/tags/HTML/"/>
    
      <category term="CSS" scheme="https://seven1011.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>HTML&amp;CSS基础知识(二)</title>
    <link href="https://seven1011.github.io/2019/11/03/HTML-CSS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E4%BA%8C/"/>
    <id>https://seven1011.github.io/2019/11/03/HTML-CSS基础知识-二/</id>
    <published>2019-11-02T18:06:37.000Z</published>
    <updated>2019-11-02T10:55:52.753Z</updated>
    
    <content type="html"><![CDATA[<pre><code>【介绍】HTML&amp;CSS必知必会，学习笔记</code></pre><a id="more"></a><h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><ul><li>最基础的网页开发语言  </li></ul><ul><li>Hyper Text Markup Language 超文本标记语言  </li></ul><p>&emsp; <strong>超文本：</strong><br>&emsp;&emsp; 超文本使用超链接的方法，将各种不同空间的文字信息组织在一起的网状文本<br>&emsp; <strong>标记语言：</strong><br>&emsp;&emsp;有标签构成的语言<br><br></p><h2 id="2-快速入门"><a href="#2-快速入门" class="headerlink" title="2. 快速入门"></a>2. 快速入门</h2><ul><li><p><strong>语法：</strong>  </p><ol><li><p>html文档的后缀名是.html或者.htm   </p></li><li><p>标签分为:  </p><pre><code>1. 围堵标签：有开始标签和结束标签。如&lt;html&gt;  &lt;/html&gt;2. 自闭合标签：开始标签和结束标签在一起。如&lt;/br&gt;  </code></pre></li><li><p>标签可以嵌套</p><pre><code>需要正确嵌套，不能你中有我，我中有你</code></pre></li><li><p>在开始标签中可以定义属性。属性是由键值对构成，值需要用引号（单双都可）引起来</p></li><li><p>html的标签不区分大小写，但是建议使用小写。</p><br></li></ol></li></ul><h2 id="3-标签学习"><a href="#3-标签学习" class="headerlink" title="3. 标签学习"></a>3. 标签学习</h2><h4 id="文件标签：构成html的最基本的标签"><a href="#文件标签：构成html的最基本的标签" class="headerlink" title="文件标签：构成html的最基本的标签"></a>文件标签：构成html的最基本的标签</h4><br><pre><code>html：html文档的根标签head：头标签。用于指定html文档的一些属性。引入外部的资源。title：标题标签body：体标签&lt;!DOCTYPE html&gt;：html5定义文档类型</code></pre><br><h4 id="文本标签：和文本有关的标签"><a href="#文本标签：和文本有关的标签" class="headerlink" title="文本标签：和文本有关的标签"></a>文本标签：和文本有关的标签</h4><br><pre><code>&lt;h1&gt; to &lt;h6&gt;：标题标签 自带换行效果&lt;p&gt;：段落标签&lt;br&gt;：换行标签&lt;hr&gt;：显示一条水平线     属性（html5不建议使用）： color（颜色） width（宽度）size（高度）align（对齐方式：center、left、right)  &lt;b&gt;：字体加粗&lt;i&gt;：斜体&lt;font&gt;(已经过时)：字体标签（属性：color、size、face（字体））&lt;center&gt;(过时标签)：文本居中</code></pre><br><h4 id="图片标签"><a href="#图片标签" class="headerlink" title="图片标签"></a>图片标签</h4><br><pre><code>img：展示图片src：存放图片的路径，一般写相对路径：以.开头       ./：代表当前目录       ../：代表上一级目录</code></pre><br><h4 id="列表标签"><a href="#列表标签" class="headerlink" title="列表标签"></a>列表标签</h4><br><pre><code>无序列表    &lt;ul&gt;：项目使用粗体远点进行标记有序列表    有序列表始于 &lt;ol&gt; 标签。每个列表项始于 &lt;li&gt; 标签自定义列表    自定义列表以 &lt;dl&gt; 标签开始。每个自定义列表项以 &lt;dt&gt; 开始。每个自定义列表项的定义以 &lt;dd&gt; 开始</code></pre><br><h4 id="连接标签"><a href="#连接标签" class="headerlink" title="连接标签"></a>连接标签</h4><br><pre><code>&lt;a&gt;</code></pre><ul><li><p>样式</p><pre><code>&lt;div&gt;：定义文档中的节&lt;span&gt;：定义文档中的节</code></pre><br></li></ul><h4 id="语义化标签：html5中为了提高程序的可读性，提供了一些标签"><a href="#语义化标签：html5中为了提高程序的可读性，提供了一些标签" class="headerlink" title="语义化标签：html5中为了提高程序的可读性，提供了一些标签"></a>语义化标签：html5中为了提高程序的可读性，提供了一些标签</h4><br><pre><code>1. &lt;header&gt;2. &lt;footer&gt;</code></pre><br><h4 id="表格标签"><a href="#表格标签" class="headerlink" title="表格标签"></a>表格标签</h4><br><pre><code>&lt;table&gt;标签用于显示一个表格属性：    border：表格的边框    width：宽度（单位px：像素）    cellpadding：定义内容和单元格的举例    cellspacing：定义单元格之间的距离。如果指定为领，则单元格的线会合为一条    bgcolor：背景色    align：对齐方式&lt;tr&gt; 表示行&lt;th&gt;：定义表头单元格&lt;td&gt; 表示列又叫单元格    width：宽度（表示：1.px   2.百分比）    align：对齐方式    valign：单元格垂直对齐    colspan：横跨两列，水平合并    bgcolor：背景色    colspan：合并列    rowspan：合并行&lt;caption&gt;：表格标题&lt;thead&gt;：表示表格头的部分&lt;tbody&gt;：表示表格头的部分&lt;tfoot&gt;：表示表格头的部分</code></pre><br><ul><li><strong>属性定义：</strong><br></li></ul><p><strong>color:</strong></p><pre><code>1. 英文单词：red，green2. rgb(值1，值2，值3)：值的范围：0~255  如：rgb(0,0,255)3. #值1值2值3：值的范围：00~FF之间。如：#FF00FF</code></pre><br><p><strong>width:</strong></p><pre><code>1. 数值：width=&quot;20&quot;，数值的单位，默认是  px(像素)2. 百分比：占相对父元素的比例</code></pre><br>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;【介绍】HTML&amp;amp;CSS必知必会，学习笔记&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="HTML" scheme="https://seven1011.github.io/categories/HTML/"/>
    
      <category term="CSS" scheme="https://seven1011.github.io/categories/HTML/CSS/"/>
    
    
      <category term="HTML" scheme="https://seven1011.github.io/tags/HTML/"/>
    
      <category term="CSS" scheme="https://seven1011.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>HTML&amp;CSS基础知识(一) </title>
    <link href="https://seven1011.github.io/2019/11/02/HTML-CSS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E4%B8%80/"/>
    <id>https://seven1011.github.io/2019/11/02/HTML-CSS基础知识-一/</id>
    <published>2019-11-02T11:02:42.000Z</published>
    <updated>2019-11-02T09:58:35.240Z</updated>
    
    <content type="html"><![CDATA[<pre><code>【介绍】HTML&amp;CSS必知必会，学习笔记</code></pre><a id="more"></a><hr><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容:"></a>主要内容:</h2><p>&emsp;&emsp;1. web概念概述<br>&emsp;&emsp;2. HTML</p><hr><h2 id="web概念概述"><a href="#web概念概述" class="headerlink" title="web概念概述"></a>web概念概述</h2><h3 id="JavaWeb："><a href="#JavaWeb：" class="headerlink" title="JavaWeb："></a>JavaWeb：</h3><p> &emsp;&emsp; 使用java语言开发基于互联网的项目<br> <br></p><h3 id="软件架构："><a href="#软件架构：" class="headerlink" title="软件架构："></a>软件架构：</h3><h4 id="1-C-S-Client-Sertver-客户端-服务器端"><a href="#1-C-S-Client-Sertver-客户端-服务器端" class="headerlink" title="1. C/S:  Client/ Sertver 客户端/服务器端"></a>1. C/S:  Client/ Sertver 客户端/服务器端</h4><p>&emsp;<strong>优点</strong></p><p>&emsp;&emsp; 1. 用户体验好</p><p>&emsp;<strong>缺点</strong></p><p>&emsp;&emsp; 1. 开发、安装、部署、维护麻烦<br> <br></p><h4 id="2-B-S-Browser-Server-浏览器-服务器端"><a href="#2-B-S-Browser-Server-浏览器-服务器端" class="headerlink" title="2. B/S: Browser/Server  浏览器/服务器端"></a>2. B/S: Browser/Server  浏览器/服务器端</h4><p>&emsp;<strong>优点：</strong></p><p>&emsp;&emsp;   1. 开发、安装、部署、维护简单</p><p>&emsp;<strong>缺点：</strong></p><p>  &emsp;&emsp;   1. 如果应用过大，用户可能受到影响</p><p>   &emsp;&emsp;     2. 对硬件要求过高</p><p><strong>详细介绍</strong><br> <br></p><p>&emsp;<strong>资源分类</strong><br> &emsp;<strong>1. 静态资源：</strong></p><p>   &emsp;&emsp; 使用静态网页开发技术发布的资源</p><p>   &emsp; 特点：</p><p>   &emsp;&emsp; 所有用户访问，得到的结果是一样的<br> <br></p><p> &emsp;<strong>2. 动态资源</strong></p><p>&emsp;&emsp;使用动态网页及时发布的资源</p><p>&emsp; 特点：</p><p>   &emsp;&emsp; 所有用户访问，得到的结果可能不一样</p><p>   &emsp;&emsp; 如果用户请求的是动态资源，那么服务器会执行动态资源，转换为静态资源，在发送给浏览器<br> <br></p><ul><li><strong>静态资源：</strong></li></ul><p>&emsp;&emsp; &emsp;&emsp; HTML:用于搭建基础网页，展示页面的</p><p>&emsp;&emsp; &emsp;&emsp; CSS:用于美化页面，布局页面</p><p>&emsp;&emsp; &emsp;&emsp; JavaScript:控制页面的元素，让页面有一些动态的效果<br> <br></p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;【介绍】HTML&amp;amp;CSS必知必会，学习笔记&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="HTML" scheme="https://seven1011.github.io/categories/HTML/"/>
    
      <category term="CSS" scheme="https://seven1011.github.io/categories/HTML/CSS/"/>
    
    
      <category term="HTML" scheme="https://seven1011.github.io/tags/HTML/"/>
    
      <category term="CSS" scheme="https://seven1011.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>后台管理项目入门(一) </title>
    <link href="https://seven1011.github.io/2019/11/02/%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A8-%E4%B8%80/"/>
    <id>https://seven1011.github.io/2019/11/02/后台管理项目入门-一/</id>
    <published>2019-11-02T10:35:32.000Z</published>
    <updated>2019-11-02T03:08:00.068Z</updated>
    
    <content type="html"><![CDATA[<pre><code>入门（一）</code></pre><a id="more"></a><h3 id="1-项目克隆到本地："><a href="#1-项目克隆到本地：" class="headerlink" title="1.项目克隆到本地："></a>1.<strong>项目克隆到本地：</strong></h3><pre><code>git clone https://github.com/PanJiaChen/vue-element-admin.git</code></pre><h3 id="2-项目目录介绍："><a href="#2-项目目录介绍：" class="headerlink" title="2.项目目录介绍："></a>2.<strong>项目目录介绍：</strong></h3><pre><code>├── build                      // 构建相关  ├── config                     // 配置相关├── src                        // 源代码│   ├── api                    // 所有请求│   ├── assets                 // 主题 字体等静态资源│   ├── components             // 全局公用组件│   ├── directive              // 全局指令│   ├── filtres                // 全局 filter│   ├── icons                  // 项目所有 svg icons│   ├── lang                   // 国际化 language│   ├── mock                   // 项目mock 模拟数据│   ├── router                 // 路由│   ├── store                  // 全局 store管理│   ├── styles                 // 全局样式│   ├── utils                  // 全局公用方法│   ├── vendor                 // 公用vendor│   ├── views                   // view│   ├── App.vue                // 入口页面│   ├── main.js                // 入口 加载组件 初始化等│   └── permission.js          // 权限管理├── static                     // 第三方不打包资源│   └── Tinymce                // 富文本├── .babelrc                   // babel-loader 配置├── eslintrc.js                // eslint 配置项├── .gitignore                 // git 忽略项├── favicon.ico                // favicon图标├── index.html                 // html模板└── package.json               // package.json</code></pre><h3 id="2-1-components-："><a href="#2-1-components-：" class="headerlink" title="2.1 components ："></a>2.1 components ：</h3><p>&emsp;components 放置的都是全局公用的一些组件，如上传组件，富文本等等。一些页面级的组件建议还是放在各自views文件下，方便管理。</p><h3 id="2-2-store："><a href="#2-2-store：" class="headerlink" title="2.2 store："></a>2.2 store：</h3><p>  &emsp;不要为了用vuex而用vuex！</p><h3 id="2-3-webpack："><a href="#2-3-webpack：" class="headerlink" title="2.3 webpack："></a>2.3 webpack：</h3><blockquote><p>本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。</p></blockquote><p>&emsp;从 webpack v4.0.0 开始，可以不用引入一个配置文件。然而，webpack 仍然还是<a href="https://www.webpackjs.com/configuration" target="_blank" rel="noopener">高度可配置的</a>。在开始前你需要先理解四个<strong>核心概念</strong>：</p><p> &emsp;&emsp;入口(entry)<br> &emsp;&emsp;输出(output)<br> &emsp;&emsp;loader<br> &emsp;&emsp;插件(plugins)</p><h3 id="2-4-axios的封装"><a href="#2-4-axios的封装" class="headerlink" title="2.4 axios的封装"></a>2.4 axios的封装</h3><p>&emsp;<strong>目的：</strong>帮助我们简化代码和有利于后期的更新和维护。<br><br></p><p>&emsp;&emsp;&emsp;axios库经常被用在vue项目和后台交互数据方面，可以运行在浏览器端和node.js中。<br><br></p><p>&emsp;<strong>优点：</strong>拦截请求和响应、取消请求、转换json、客户端防御XSRF<br><br></p><h4 id="2-4-1-安装"><a href="#2-4-1-安装" class="headerlink" title="2.4.1 安装"></a>2.4.1 安装</h4><p>&emsp;&emsp;<code>npm install axios; // 安装axios</code></p><h4 id="2-4-2-引入"><a href="#2-4-2-引入" class="headerlink" title="2.4.2 引入"></a>2.4.2 引入</h4><p>&emsp;在src目录之中新建request文件夹，然后新建http.js和一个api.js文件。其中<br><br></p><p>&emsp;&emsp;http.js:封装我们的axios<br>&emsp;&emsp;api.js:统一管理我们的接口<br><br></p><p>&emsp;关于环境切换、设置请求超时、post请求头设置系列操作参考<a href="https://juejin.im/post/5b55c118f265da0f6f1aa354" target="_blank" rel="noopener">《vue中Axios的封装和API接口的管理》</a></p><h3 id="2-5-安装ESLint插件"><a href="#2-5-安装ESLint插件" class="headerlink" title="2.5 安装ESLint插件"></a>2.5 安装ESLint插件</h3><p>&emsp;<strong>ESLint插件+VSCode进行代码编写</strong><br><br></p><p>&emsp;对VSCode进行扩展设置  文件 &gt; 首选项 &gt; 设置 打开 VSCode 配置文件,添加如下配置：<br><br></p><pre><code>&quot;files.autoSave&quot;:&quot;off&quot;,&quot;eslint.validate&quot;: [&quot;javascript&quot;,&quot;javascriptreact&quot;,&quot;html&quot;,{ &quot;language&quot;: &quot;vue&quot;, &quot;autoFix&quot;: true }],&quot;eslint.options&quot;: {&quot;plugins&quot;: [&quot;html&quot;]}</code></pre><br>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;入门（一）&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="Element" scheme="https://seven1011.github.io/categories/Element/"/>
    
      <category term="Vue" scheme="https://seven1011.github.io/categories/Element/Vue/"/>
    
    
      <category term="Vue，Element" scheme="https://seven1011.github.io/tags/Vue%EF%BC%8CElement/"/>
    
      <category term="项目实战" scheme="https://seven1011.github.io/tags/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>Yarn简单介绍及报错处理</title>
    <link href="https://seven1011.github.io/2019/11/02/webpack-dev-server-%E4%B8%8D%E6%98%AF%E5%86%85%E9%83%A8%E6%88%96%E5%A4%96%E9%83%A8%E5%91%BD%E4%BB%A4%EF%BC%8C%E4%B9%9F%E4%B8%8D%E6%98%AF%E5%8F%AF%E8%BF%90%E8%A1%8C%E7%9A%84%E7%A8%8B%E5%BA%8F%E6%88%96%E6%89%B9%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6/"/>
    <id>https://seven1011.github.io/2019/11/02/webpack-dev-server-不是内部或外部命令，也不是可运行的程序或批处理文件/</id>
    <published>2019-11-02T10:14:36.000Z</published>
    <updated>2019-11-09T13:17:08.105Z</updated>
    
    <content type="html"><![CDATA[<pre><code>【介绍:】Yarn简单介绍及：webpack-dev-server 不是内部或外部命令报错解决办法</code></pre><a id="more"></a><hr><p>Yarn 的全称是 <strong>Yet Another Resource Negotiator</strong>，意思是“另一种资源调度器”，是一个新的快速安全可信赖的可以替代NPM的依赖管理工具，由 facebook 推出并开源。</p><hr><p>运行项目显示缺少必要的插件<br><br></p><p>运行npm下载</p><pre><code>npm install webpack-dev-server --save</code></pre><br><p>安装成功之后再次运行</p><pre><code>yarn install</code></pre><br><p>结果还是报错</p><pre><code>Error: Cannot find module &apos;webpack&apos;    at Function.Module._resolveFilename (internal/modules/cjs/loader.js:636:15)    at Function.Module._load (internal/modules/cjs/loader.js:562:25)    at Module.require (internal/modules/cjs/loader.js:690:17)    at require (internal/modules/cjs/helpers.js:25:18)    at Object.&lt;anonymous&gt; (E:\code\admin\vue-antd-admin\node_modules\webpack-dev-server\lib\Server.js:22:17)    at Module._compile (internal/modules/cjs/loader.js:776:30)    at Object.Module._extensions..js (internal/modules/cjs/loader.js:787:10)    at Module.load (internal/modules/cjs/loader.js:653:32)    at tryModuleLoad (internal/modules/cjs/loader.js:593:12)    at Function.Module._load (internal/modules/cjs/loader.js:585:3)</code></pre><p>索性删除项目目录下的<code>node_modules</code>文件夹</p><blockquote><p>npm 的工作是把将各种各样的包拉到您的计算机上，并且进行管理，这是 Nodejs 周边生态的重要体现，而node_modules文档就是存放这些安装包的地方。</p></blockquote><p>然后重新运行</p><pre><code>yarn install</code></pre><p>再运行</p><pre><code>yarn install</code></pre><p>成功运行。<br><br></p><p>解决<code>Error: Cannot find module &#39;webpack&#39;</code>可以尝试<a href="https://juejin.im/post/5cb860445188253b454b7568" target="_blank" rel="noopener">这里</a>…<br><br></p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;【介绍:】Yarn简单介绍及：webpack-dev-server 不是内部或外部命令报错解决办法&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="webpack" scheme="https://seven1011.github.io/categories/webpack/"/>
    
    
      <category term="webpack" scheme="https://seven1011.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>Yarn安装过程过程及可能出现的问题</title>
    <link href="https://seven1011.github.io/2019/11/02/bash-yarn-command-not-found/"/>
    <id>https://seven1011.github.io/2019/11/02/bash-yarn-command-not-found/</id>
    <published>2019-11-01T22:27:58.000Z</published>
    <updated>2019-11-09T13:15:57.026Z</updated>
    
    <content type="html"><![CDATA[<pre><code>【介绍：】Yarn安装过程及报错 bash: yarn command not found 解决办法</code></pre><a id="more"></a><h2 id="错误介绍"><a href="#错误介绍" class="headerlink" title="错误介绍"></a>错误介绍</h2><br><p>在bash中安装依赖   </p><p> &nbsp;&nbsp;&nbsp;&nbsp;    <code>yarn install</code><br><br></p><p>出现如下错误</p><p> &nbsp;&nbsp;&nbsp;&nbsp;    <code>bash: yarn: command not found</code><br><br></p><p>这是因为npm没有安装yarn，使用npm进行安装</p><p> &nbsp;&nbsp;&nbsp;&nbsp;    <code>npm install -g yarn</code></p><p><strong>解释：</strong><code>-g(-global)</code> 该命令就是以全局模式安装yarn</p><blockquote><p><strong>注意：</strong>通常情况下不建议通过npm进行安装。npm安装是非确定性的，程序包没有签名，并且npm除了做了基本的SHA1哈希之外不执行任何完整性检查，这给安装系统程序带来了安全风险。</p></blockquote><p>除此之外，还有通过适合自己操作系统的安装方法来安装yarn<br><br></p><h3 id="windows："><a href="#windows：" class="headerlink" title="windows："></a>windows：</h3><br><ol><li><p>进入<a href="https://yarnpkg.com/en/docs/install#windows-stable" target="_blank" rel="noopener">官网下载页面</a>安装(按照引导操作完成)</p><br></li><li><p>安装完成之后查看yarn版本</p><pre><code>yarn --version</code></pre></li></ol><pre><code>![](/images/picture/20191029143233-8e86a4fa-67af-478b-a2dc-edde7bc70c08.png)</code></pre><br>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;【介绍：】Yarn安装过程及报错 bash: yarn command not found 解决办法&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="yarn" scheme="https://seven1011.github.io/categories/yarn/"/>
    
    
      <category term="yarn" scheme="https://seven1011.github.io/tags/yarn/"/>
    
  </entry>
  
  <entry>
    <title>少年的你已然成年</title>
    <link href="https://seven1011.github.io/2019/10/26/%E5%B0%91%E5%B9%B4%E7%9A%84%E4%BD%A0%E5%B7%B2%E7%84%B6%E6%88%90%E5%B9%B4/"/>
    <id>https://seven1011.github.io/2019/10/26/少年的你已然成年/</id>
    <published>2019-10-26T10:00:44.000Z</published>
    <updated>2019-10-27T05:08:56.969Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/picture/%E5%B0%91%E5%B9%B4%E7%9A%84%E4%BD%A0.jpg" alt></p><a id="more"></a><hr><p><strong>写在前面的话</strong>：有剧透，仅仅从自己的角度来谈谈《少年的你》。</p><hr><p>电影中的人物大致有这么几类。</p><h1 id="一、魏莱"><a href="#一、魏莱" class="headerlink" title="一、魏莱"></a>一、魏莱</h1><br><p><strong>好看皮囊下扭曲的灵魂。</strong>魏莱在警局接受调查，得知通知魏母之后，露出丑恶的面目。本以为会就此忏悔，结果在郑警官到家进行调查时，家中的豪华的装饰和英文奖杯以及魏母的态度，让平凡的郑警官感到无力感，凸显以陈念为代表的底层大众维护自身权利的艰辛。<br><br></p><p><strong>暴力是可以上瘾的。</strong>在受到退学处分以及小北的恐吓之后。魏反而变本加厉。是因为保利会上瘾的，所以他会在胡小蝶自杀之后，找到陈念，找到她昔日的同伴，对他们进行施暴。</p><h1 id="二、郑易"><a href="#二、郑易" class="headerlink" title="二、郑易"></a>二、郑易</h1><br>最开始在屏幕上出现的郑警官是一个血气方刚、一腔正义的年轻人。他对胡小蝶的自杀、陈念的知情不说而大声呵斥。后来有位陈念受到校园暴力而尽力地维护他。<br><p><strong>“成年后好多事情都可以忘记”</strong>后来他这样安慰陈念，成年之后确实会看淡很多事情，人随之变得大度，没有更多的空闲的时间去想一些无关紧要的事情。但是，少年时期受到的创伤确实无法弥补的，心里的阴影更是一辈子的烙印。<br><br></p><p>郑易从陈念是犯罪嫌疑人却坚持维护他去高考，<br><br></p><p>到    <strong>“你觉得会有这样的人会了对方做几十年的牢吗？”</strong><br><br></p><p><strong>“你和我不会，可是他们是少年”</strong>这样同事之间的对话。<br><br></p><p>  再到后来老杨对他说  一个好学生，一个小混混，都被你拉下水，夸赞他成熟了。<br><br></p><p>郑易也得到了成长，而他所做的是为了守护两个孩子的未来。<br><br></p><p>小北守护的是陈念的那份善良，陈年坚守的是终有一天他们可以光明正大肩并肩的周在大家上的信念。</p><h1 id="三、小北"><a href="#三、小北" class="headerlink" title="三、小北"></a>三、小北</h1><br>生活在底层的泥泞之中，原生家庭对他造成了巨大的影响。<br><p><strong>世界上有两种人，一种是挨打的，一种是打人的。</strong>他有自己对世界的见解，直到他碰到陈念。<br><br></p><p><strong>即使身处阴沟，也要仰望星空。</strong><br><br></p><p>陈年是他的逃生口。从此，他的生活才有了光和希望。所以它潜行在黑暗之中，不顾一切的想要保护陈念。<br><br></p><p><strong>“你保护世界，我保护你”</strong>陈念太干净纯洁了，即使遭受校园霸凌，她依然可以这样说。就像他在警局接受审讯时所讲：<br><br></p><p><strong>如果世界是这个样子，你还敢把你的孩子生下来吗？</strong><br><br></p><p>小贝儿守护的酒是陈念心中的那份善良。</p><h1 id="四、陈念"><a href="#四、陈念" class="headerlink" title="四、陈念"></a>四、陈念</h1><br><p>校园霸凌受害者。他一直坚信高考之后一切都会好起来，可以保妥魏莱的欺辱，帮助母亲还清债务，和小北光明正大的肩并肩走在大街上。<br><br></p><p>他和小北彼此珍惜，彼此珍重，两个人组成“共生体”，在黑暗的世界里寻找光明。<br><br></p><p>努力学习，通过高考走出小镇，是陈念的唯一念头，也是现实世界中多少学子的梦想，把希望孤注一掷的寄于高考。<br><br></p><p>陈念身上反映的不仅仅是校园暴力问题，还有教育方面的问题。<br><br></p><p>在胡晓蝶自杀之后，郑易问她你有什么朋友，他当时回答 <strong>“在这里不需要朋友。”</strong><br><br></p><p>之后的镜头更是显示高楼层走廊外面安装上的防盗窗，为了防止学生跳楼安装防盗窗的学校不在少数，这样只堵不疏的方式意义又在哪里？</p><h1 id="五、另一类就是目睹校园暴力受害者身陷沼泽之中却无动于衷的冷漠旁观者"><a href="#五、另一类就是目睹校园暴力受害者身陷沼泽之中却无动于衷的冷漠旁观者" class="headerlink" title="五、另一类就是目睹校园暴力受害者身陷沼泽之中却无动于衷的冷漠旁观者"></a>五、另一类就是目睹校园暴力受害者身陷沼泽之中却无动于衷的冷漠旁观者</h1><br><p><strong>最后，人生苦短，请你善良！希望大家都能有一美好安静又难忘的岁月…</strong><br><br></p><p>  真的很喜欢电影中人物的台词，很耐人寻味（周冬雨和易烊千玺的演技都挺赞~）</p><br><br>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/picture/%E5%B0%91%E5%B9%B4%E7%9A%84%E4%BD%A0.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="电影" scheme="https://seven1011.github.io/categories/%E7%94%B5%E5%BD%B1/"/>
    
    
      <category term="电影，感想" scheme="https://seven1011.github.io/tags/%E7%94%B5%E5%BD%B1%EF%BC%8C%E6%84%9F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>于宙：我们这一代人的困惑</title>
    <link href="https://seven1011.github.io/2019/10/24/%E4%BA%8E%E5%AE%99%EF%BC%9A%E6%88%91%E4%BB%AC%E8%BF%99%E4%B8%80%E4%BB%A3%E4%BA%BA%E7%9A%84%E5%9B%B0%E6%83%91/"/>
    <id>https://seven1011.github.io/2019/10/24/于宙：我们这一代人的困惑/</id>
    <published>2019-10-24T13:34:22.000Z</published>
    <updated>2019-10-25T10:27:37.725Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/picture/20191024141822.png" alt></p><a id="more"></a><p>原文地址：<a href="http://blog.sina.com.cn/s/blog_70e965880102ve5v.html" target="_blank" rel="noopener">JOIN创业实战笔记的博客</a><br>视频链接：<a href="https://link.zhihu.com/?target=http%3A//v.qq.com/boke/page/e/0/9/e0143xi01p9.html" target="_blank" rel="noopener">   【TEDxDUFE】于宙  </a></p><hr><p><strong>导读</strong>：本文是于宙在TEDx大会上的演讲，这篇文章有点长，不过非常值得你花20分钟把它看完。本周如果只能推荐一篇文章，那么强烈建议你读读这一篇，“一个有故事的大叔说的实在话”。</p><hr><p><strong>以下是演讲全文：</strong><br><br><br>大家下午好，</p><p>很荣幸能够参加本次TEDx大会，非常感谢东北财经大学TED团队和华臣影城为我们提供这样一个交流的机会。<br><br><br><strong>自我介绍</strong><br><br><br>我是大连人，高中就读于大连市二十四中。因为当时学习十分不努力，所以高中毕业之后选择了出国留学，这其实是很多本科出国留学的人不能说的秘密，辗转了几个学校，最终毕业于美国印第安纳大学凯利商学院，主修投资和金融衍生品。上学的时候迷恋炒股，学习依旧散漫，没能成为一个“放弃了华尔街的高薪工作毅然回国”海归精英，真的颇为遗憾，因为实在没有什么华尔街的公司愿意要我。碰巧的是，毕业前两年股市和外汇的行情比较好，赚到了一点点资本，于是我决定回国做点生意。现在在大连从事餐饮行业，目前拥有万达广场的不出二品，大都会，福佳新天地，奥林匹克广场的莉蒂娅城堡4家芝士蛋糕店，青泥洼桥2路车站，长春路百盛，和即将开业的罗斯福地下的乔东家脆皮火烧三家火烧店。<br><br><br><strong>引言</strong><br><br><br>大学毕业之后第一次面对这么多人做演讲，坦率地说，非常的紧张。虽然年轻的时候我曾经畅想过很多次，功成名就之后能像我曾经的那些偶像一样和年轻的朋友们分享一下我是如何从一无所有走上人生巅峰的经验，然后语重心长的告诉大家，人活着不能像一根草而是要像一棵树，能走到金字塔顶端的只有雄鹰和蜗牛两种动物，我的成功你也可以复制等等。可是过了26岁之后我忽然意识到一个严肃的问题，就是自己的一生未必会取得很大的成就啊，所以当TEDxDUFE团队找到我说没关系即便你只是一个开小吃店的，我们也愿意为你提供这样一个和很多人交流思想的机会时，我的心情是多么地激动。因为公司还没上市，所以小草大树，雄鹰蜗牛，睡地板捡易拉罐这样的故事还不到说的时候。今天，只想和大家分享几个困扰了我和我身边的一些朋友十几年的问题，和在经历了一些变故和挫折后，我对这些问题的看法。<br><br><br><strong>努力奋斗真的能实现梦想吗？</strong><br><br><br>大家现在可以想象一下汪峰老师坐在转椅上，深情的望着你对你说，“你的梦想是什么？”周星驰老师的那句“做人如果没有梦想，和咸鱼有什么区别？”据说也激励了几代人。梦想这个东西是如此的重要，简直就是人生的一盏明灯。成功的人们成功的原因各不相同，但他们都不会忘记告诉你，无论到什么时候，都不曾忘记梦想，是他们成功的首要原因。以至于我们这一代人对于人生意义的最通常的理解，就在于坚持梦想并最终实现它。可很少有人愿意面对的一件事情是，大部分人的梦想永远，没错，永远都实现不了。  </p><p>你没听错，大部分人的梦想永远都实现不了。</p><p>先和大家分享一个我之前的梦想。上大学的时候我热衷于各式各样的赌博游戏，是学校旁边赌场的常客。我赌徒生涯的起点源于赌场里最基本游戏轮盘赌，轮盘上1到36个数字和两个0，赔率是1赔36。1到36分为红黑两色，押注红黑的赔率是1赔1。作为一个合格的接受过九年义务教育的人都知道，每一次轮盘开始转动的那一刻，都是一次纯粹的独立随机事件。但是赌博这件事情的魅力就在于，当你真正身处赌场，看到已经连续4次开出红色的时候，几乎所有人都会想把筹码压在黑色的那一面。而我当时的梦想，就是破译这其中的奥秘。我最初的策略非常简单，当连续三次开出奇数，就押注偶数，连续三次红色，就押注黑色。难以置信的事情发生了，在我严格的执行这个策略的情况下，前几次去赌场不但全身而退，每次都还赚了不少，以至于我产生了一种幻觉，也许游戏是有规律可循的，我已经看到了人生巅峰就在不远处向我招手。当然最终的结尾你们一定想到了，在经历过连续18个偶数，连续开出21次黑色后，我把之前赚到的钱都乖乖地还给了赌场。</p><p>后来我知道，我那个愚蠢的梦想叫做赌徒谬论，就不具体展开讲了。但它对我意义深刻，我终于明白了在纯粹的随机事件面前，一切规律都是无谓的。</p><p>生活中的事情有极个别和轮盘赌一样，属于纯粹的随机事件，比如双色球。可是几乎每一个中了双色球的人都会告诉你啊，他们花了多少精力去钻研往期号码，研究历史规律，付出了多少辛勤的努力最终获得了成功。实际上，即使是纯粹由随机性主导的事情，只要参与的人的基数足够大，小概率事件总会发生。有趣的是，几乎所有在随机事件中的受益者，都会把这完全由运气决定的结果归功于自己的努力上。不仅仅是参与者本身，旁观者也会这么认为。再比如，中国好声音的冠军嘛。<br><br><br><strong>我们生活中遇到的所有事情基本可以分为三类，第一类纯粹由随机性决定，比如布朗运动和轮盘赌博，第二类纯粹由能力决定，比如英语六级考试，110米栏之类。第三类，也是我们最常遇到的，由能力和随机性共同决定，比如创业，投资，恋爱或是梦想。</strong><br><br><br>我对励志大师们总告诉年轻人要不惜一切代价追逐梦想感到深深厌倦的原因就在于，大多数人的梦想虽然不是纯粹的双色球，但也绝对是由随机性主导的。在强大的随机性面前，付出再多辛勤的汗水，就好比夜以继日蹲在轮盘赌旁边渴望参透其中规律。前面说到中国好声音的冠军，张碧晨的那一句you are my destiny，听得我也是醉了。但毕竟那一刻，中国又有多少唱歌唱的和她一样好甚至更好的姑娘，如果真把成为好声音冠军作为一生的梦想，一生中都得在痛苦中度过。我个人很喜欢黄渤，但绝对不会用黄渤作为例子去激励一个我这种长相差的年轻人不惜一切代价去追逐演员梦，注意是不惜一切代价。因为无论是唱歌还是演戏，再多的努力也只能让你变得很优秀，它们并不存在可以量化的评判标准，想成为万众瞩目明星，随机性的重要程度都远远大于实力。<br><br><br>我想，<strong>一个人在年轻的时候，做的每一件事情，能清楚的区分其中随机性所占的比例并能心平气和的接受它，在我看来就是最宝贵的财富。</strong><br><br><br>那么在你的梦想中，运气又扮演了多重要的角色呢？当你深深的感知到这件事情的随机性也许不会青睐与你，是否还愿意坚持下去呢？对我而言，梦想永远是值得执着追求的，但我可以无比心平气和的接受，它就是永远无法实现。<br><br><br><strong>既然连梦都实现不了，还有什么事情值得努力呢？</strong><br><br><br>去年这个时候，我发过一条微博。</p><p><strong>这些年我一直提醒自己一件事情，千万不要自己感动自己。大部分人看似的努力，不过是愚蠢导致的。什么熬夜看书到天亮，连续几天只睡几小时，多久没放假了，如果这些东西也值得夸耀，那么富士康流水线上任何一个人都比你努力多了。人难免天生有自怜的情绪，唯有时刻保持清醒，才能看清真正的价值在哪里。</strong><br> <br><br>这段话在网上的疯传，是我始料不及的。更出乎我意料之外的是，我在评论中看到了相当一部分的骂声，还有人认真的给我写下了相当深刻的话，“你在拥有自己的光亮时不要吹熄别人的蜡烛，你不能因为你自己的不喜欢就否定别人。”很莫名其妙是吧，即使你刚刚听完我上一段关于随机性的看法，你也会知道，我从来都不觉得努力是一件无所谓的事情。恰恰相反，我一直相信，在能力没达到一定程度之前，你连面对随机性的资格都没有啊。张碧晨能拿好声音冠军自然离不开运气，但换成杨幂，评委不但不会转身可能直接撒腿就跑了。</p><p>可现在问题来了，那究竟什么才算是有价值的努力？这可以从我那条微博说起。去年这个时候我和朋友在琢磨去大庆做点服装生意，决定去考察几个商场。我当时住在北京，因为之前晚上和朋友在外面玩的比较尽兴回到家里已经比较晚了，担心睡觉睡过头会错过航班，那晚上就直接在沙发上靠了一晚。那是我第一次去哈尔滨，十一月份已经很冷了，衣服拿的不足，下了飞机冻得头疼。又因为没有提前订票，到了哈尔滨之后才买的火车票，发现就只剩站票了。于是，当我一晚上没睡，冻得头晕眼花，又在绿皮火车上站了两个多小时之后，抵达大庆的那一瞬间我觉得自己实在是太不容易了，将来必须要写进回忆录里面。可是，回头仔细一想，这些所谓的“努力”对我最终把那个服装生意做好，没有半毛钱关系。更何况，如果我前一天晚上能早点上床睡觉，多准备点衣服，提前在网上把火车票订好，完全可以舒舒服服的达到同样的目的。我的那次经历像是自己二十多年生活中很多事情的缩影，沉溺在对结果没有直接帮助只是因为自己遭受了一些痛苦的行为中，误以为那就是努力。<br><br><br><strong>当我终于意识到我并不是唯一曾经把无意义的消耗当作努力的时候，忽然发现，原来生活中我觉得很努力的人，也许没那么勤奋，如果在正确的方向上坚持行动，超过他们也并不困难。</strong><br><br><br>因为我们这一代人对于勤奋和努力的理解，几乎清一色的来自于学校，更精确的说，在前二十多年的生活中，我们眼中最努力的人，就是那些最能拼命看书和做题的人。实际上，这种理解是极其片面而幼稚的，因为看书和做题本身，都是为了一个极其鲜明的目的而存在的，就是通过考试。这种勤奋的付出极其纯粹，更多的复习时间，更高的复习强度，一般而言，都可以直接的提高考试的分数，它们之间的联系鲜明而直接，每个人都看的懂。<br><br><br><strong>但生活的美妙之处却在于，很多事情在我们没做到一定程度之前，是完全没法理解的。</strong><br><br><br>这就好比学英语，十几年漫长的岁月里我都在幻想，要通过多么复杂的流程，多么精密的设计，多么全面的涉及和多么不可思议的努力，终于有那么一天，或许就我就能因为前期的那些无懈可击的学习，说一口比较流利的英语，像说中文一样，可以边说边想，而不是说每一句话之前设计它的句式时态词汇然后在心里复述几遍再看上去流利的背诵出来。谁不是这么设想的呢？可惜，它不仅从来没有实现，并且让我看不到有任何实现的趋势，对于每一个设立目标的人来说，没有比这更痛苦的感受。</p><p>但是在去了美国两年左右的时间之后，我忽然发现自己可以已经毫无障碍的说一口流利的英语了。这并非我采用了什么新的学习方法，而是因为去了印第安纳之后身边中国人很少，在没有选择的情况下，只能被迫用英语去交流和表达，在这个过程中我并没有认真想过自己每天进步了多少，也没有阶段性的检验学习效果，只是不停的去听和说，因为没有选择嘛。直到两年多后的忽然有一天我才意识到，咦，自己好像真的已经可以了。但是我确实无法总结出来是如何一步一步做到的，只是那两年的时间，我一直都在很不情愿地用英语去生活嘛。<br><br><br><strong>一个人能获得的最可贵的能力，都和掌握一门语言一样，你所付出的努力不是能够获得即时回馈的，甚至在很长的一段时间内没有任何收获，直到积累到了一定的阶段后，忽然爆发出惊人的力量，连你自己都不清楚这一切是如何发生的。比如锻炼身体，读书写作，或者是做生意。当你经历了足够的量变终于引起质变时拥有的技能，大部分人是终身难以企及的，不是因为他们太笨，恰恰相反，因为他们都太聪明了。</strong><br><br><br>触发人类行动的最基本原理被称为反射，我们是需要即时回馈的物种。所以绝大多数人对于世界的理解度是线性的，但更多情况下，事物却是以漫长的潜伏震荡后爆发突破的形式发展的。我现在时常觉得，人在少年时期更容易掌握语言，乐器，美术这些成年后很难学的技艺，并非那小时候就是天资聪颖，而是小孩子很少会一个星期质疑一次自己收获了多少，都是闷头一练就是好几年，直到学会了才知道哦自己已经会了。只有聪明的成年人，才相信1本书读懂易经，10句话揭秘马云的成功之道，30天成为吉他高手的故事。<br><br><br>简而言之，<strong>现实生活中，付出和结果之间往往没有那么立竿见影。在离开学校之后，当我们遇到的很多事情不再像做题和考试之间联系的那么紧密的时候，很多人的付出都是浅尝辄止的。而最可贵的努力，是选择一个正确的方向，那些无法立即获得回报的事情，依然能付出十年如一日的专注和热情，最终的结果也许不足以让你独孤求败，但足以出类拔萃.</strong><br><br><br><strong>人这一生中是否有一个节点，过了之后一切都会好起来？</strong><br><br><br>前面说了这么多，谈论的都与目标和实现目标有关。仔细想想，我们的一生好像都是在实现目标中挣扎着度过的。上初中的时候，老师告诉你，中考的淘汰率是最高的，只要闯过去，上了高中一切就好了。但上了高中的时候发现不是那么回事嘛，高中老师又说了啊，考上大学就进了天堂。于是你考上了大学，依然空虚迷茫各种草样年华，父母老师又告诉你，找到工作就好了。工作之后发现烦恼和忧虑依然都在，女朋友给你看马云的故事，告诉你等你事业有成就好了……</p><p>你发现了吗，其实人这一辈子的每一个阶段都有新的痛苦和顾虑，周而复始，生生不息。绝对不会因为你考上大学，事业有成，迎娶了女神就从此happilyever after。但每一个阶段也有每一个阶段的快乐，无法替代。生活不是安徒生童话也不是好莱坞电影，从出生的那一刻起直到生命的尽头，都不存在什么节点，过去了之后一切幸福美满无忧无虑。<br><br><br><strong>每一段岁月都有它存在的价值，没有高低贵贱之分，都不应该被辜负。而我能想到的人这一生能做的最愚蠢的事情，就是把全部人生的希望都孤注一掷到未来的某个节点上，而忽略了生活本身应有的乐趣。哪怕你以后真正实现了那个执念中的目标，才会发现它远远没你想的那么美好。</strong>年轻的时候和哥们在操场上打篮球喝可乐的快乐，是以后高尔夫会球所品里红酒替代不了的。尤其男生，千万不要总想着等将来老子有钱了如何如何，且不说你以后很可能不会太有钱，而且相信我，就是有钱了也真的不能怎么样。<strong>生命就在每天的生活里，一切执念都是虚妄，和身边的人愉快相处，认真安排好每一天的活动，用心去感受每一天的心境，就是生活的意义本身。</strong>这其实是我今天最想分享给你们的事情。<br><br></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/picture/20191024141822.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="TED" scheme="https://seven1011.github.io/categories/TED/"/>
    
    
      <category term="TED" scheme="https://seven1011.github.io/tags/TED/"/>
    
  </entry>
  
</feed>
