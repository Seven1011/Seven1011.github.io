<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sevenの博客</title>
  
  <subtitle>时光，不会辜负每一个平静努力的人</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://seven1011.github.io/"/>
  <updated>2019-11-04T13:23:36.704Z</updated>
  <id>https://seven1011.github.io/</id>
  
  <author>
    <name>Seven</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title> TomCat新版本命令行乱码问题解决 </title>
    <link href="https://seven1011.github.io/2019/11/05/TomCat%E6%96%B0%E7%89%88%E6%9C%AC%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    <id>https://seven1011.github.io/2019/11/05/TomCat新版本命令行乱码问题解决/</id>
    <published>2019-11-04T20:56:43.000Z</published>
    <updated>2019-11-04T13:23:36.704Z</updated>
    
    <content type="html"><![CDATA[<pre><code>新版本的tomcat在命令窗口中会出现乱码情况</code></pre><a id="more"></a><br><p><img src="/images/picture/TomCat2.png" alt><br><br></p><p>新版本之后若乱码，只需要在配置文件中<code>logging.properties</code>将对应的utf-8修改为GBK即可，如下图所示：<br><br></p><p><img src="/images/picture/TomCat4.png" alt><br><br></p><p>重新启动TomCat。</p><hr><p>参考：<a href="https://bbs.csdn.net/topics/392500916" target="_blank" rel="noopener">CSDN论坛</a></p><hr><br>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;新版本的tomcat在命令窗口中会出现乱码情况&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="TomCat" scheme="https://seven1011.github.io/categories/TomCat/"/>
    
    
      <category term="TomCat" scheme="https://seven1011.github.io/tags/TomCat/"/>
    
  </entry>
  
  <entry>
    <title>Error running Tomcat 9.0.241: port out of range:-1 </title>
    <link href="https://seven1011.github.io/2019/11/05/9-0-241-port-out-of-range-1/"/>
    <id>https://seven1011.github.io/2019/11/05/9-0-241-port-out-of-range-1/</id>
    <published>2019-11-04T20:56:20.000Z</published>
    <updated>2019-11-04T13:25:34.527Z</updated>
    
    <content type="html"><![CDATA[<pre><code>运行TomCat发现报错</code></pre><a id="more"></a><p><img src="/images/picture/TomCat1.png" alt></p><p>这种情况是因为端口号不能是-1；<br><br></p><p>修改：</p><p>打开TomCat配置文件<code>./confl</code>里面的server.xml检查，修改端口，一般为80，或者1-65535之间任意一个整数：<br><br></p><p><img src="/images/picture/TomCat3.png" alt></p><p>重新启动。</p><br><p>如果出现报错：<code>java.net.BindException: Address already in use: JVM_Bind</code></p><p>说明端口冲突，修改后的端口已经被占用了。需要重新进行修改：</p><p>或者可以打开cmd命令窗口，输入<code>netstat -ano</code>，可以查看端口被占用情况。</p><hr><p>参考：<a href="https://stackoverflow.com/questions/12737293/how-do-i-resolve-the-java-net-bindexception-address-already-in-use-jvm-bind" target="_blank" rel="noopener">How do I resolve the “java.net.BindException: Address already in use: JVM_Bind” error?</a></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;运行TomCat发现报错&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="TomCat" scheme="https://seven1011.github.io/categories/TomCat/"/>
    
    
      <category term="TomCat" scheme="https://seven1011.github.io/tags/TomCat/"/>
    
  </entry>
  
  <entry>
    <title>HTML&amp;CSS基础知识(三) </title>
    <link href="https://seven1011.github.io/2019/11/04/HTML-CSS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E4%B8%89/"/>
    <id>https://seven1011.github.io/2019/11/04/HTML-CSS基础知识-三/</id>
    <published>2019-11-03T22:09:49.000Z</published>
    <updated>2019-11-04T00:21:55.190Z</updated>
    
    <content type="html"><![CDATA[<pre><code>【介绍】HTML&amp;CSS必知必会，学习笔记</code></pre><a id="more"></a><h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="css：页面美化和布局控制"><a href="#css：页面美化和布局控制" class="headerlink" title="css：页面美化和布局控制"></a>css：页面美化和布局控制</h2><h3 id="1-概念："><a href="#1-概念：" class="headerlink" title="1. 概念："></a>1. 概念：</h3><pre><code>Cascading Style Sheets 层叠样式表</code></pre><h3 id="2-好处："><a href="#2-好处：" class="headerlink" title="2. 好处："></a>2. 好处：</h3><p><strong>·功能强大</strong><br><strong>·将内容的展示和样式控制分离</strong></p><pre><code>- 降低耦合度。解耦- 让分工协作更容易- 提高开发效率</code></pre><h3 id="3-css的使用：css与html的样式结合"><a href="#3-css的使用：css与html的样式结合" class="headerlink" title="3. css的使用：css与html的样式结合"></a>3. css的使用：css与html的样式结合</h3><pre><code>1. 内联样式：在标签内使用style属性指定css代码2. 内部样式：在head标签内，定义style标签，style标签的标签体就是css代码3. 外部样式：    1. 定义css资源文件    2. 在head标签内定义link标签，引入外部资源文件</code></pre><p><strong>注意：</strong>1，2，3种方式 css作用范围越来越大。第一种方式不常用,后期常用后两种</p><h3 id="4-css语法："><a href="#4-css语法：" class="headerlink" title="4. css语法："></a>4. css语法：</h3><p><strong>格式</strong></p><pre><code>选择器{属性名1:属性值1;属性名2:属性值2;}</code></pre><p><strong>选择器：</strong>筛选具有相似特征的元素</p><p>&emsp;&emsp;注意：每一对属性需要使用<code>;</code>隔开，最后一对属性可以不加<code>;</code></p><h3 id="5-选择器："><a href="#5-选择器：" class="headerlink" title="5. 选择器："></a>5. 选择器：</h3><h4 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h4><p><strong>1. 基础选择器：</strong></p><pre><code>1. id选择器：选择具体的id属性值的元素，建议在一个html页面中id值唯一    语法：#id属性值{}2. 元素选择器：选择具有相同标签名称的元素    语法：标签名称{}    注意：id选择器优先级高于元素选择器3. 类选择器    语法：.class属性指{}    注意：类选择器优先级高于元素选择器</code></pre><p><strong>2. 扩展选择器：</strong></p><pre><code>1.  选择所有元素    语法：*{}2. 并集选择器    选择器1，选择器2{}3. 子选择器：筛选选择器1下的选择器2元素    语法：选择器1  选择器2{}4. 父选择器：筛选选择器2的父元素选择器1    语法：选择器1&gt;选择器2{}5. 属性选择器：选择元素名称，属性名=属性指的元素    语法：元素名称[属性名=“属性指”]{}6. 为类选择器：选择一些元素具有的状态    语法：元素：状态{}    状态：    link：初始化的状态    visited：被访问过的状态    active：正在访问的状态    hover：鼠标悬浮的状态</code></pre><h3 id="6-属性"><a href="#6-属性" class="headerlink" title="6. 属性"></a>6. 属性</h3><p><strong>1. 字体、文本</strong></p><pre><code>font-size：字体大小color：文本颜色text-align：对齐方式line-height：行高</code></pre><p><strong>2. 背景</strong></p><pre><code>background</code></pre><p><strong>3. 边框</strong></p><pre><code>border：设置表框、符合属性</code></pre><p><strong>4. 尺寸</strong></p><pre><code>width：宽度height：高度</code></pre><p><strong>5. 盒子模型</strong></p><pre><code>margin：外边距padding：内边距默认情况下内边距会影响盒子的大小</code></pre><hr><p><strong>来源：</strong>学习笔记</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;【介绍】HTML&amp;amp;CSS必知必会，学习笔记&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="HTML" scheme="https://seven1011.github.io/categories/HTML/"/>
    
      <category term="CSS" scheme="https://seven1011.github.io/categories/HTML/CSS/"/>
    
    
      <category term="HTML" scheme="https://seven1011.github.io/tags/HTML/"/>
    
      <category term="CSS" scheme="https://seven1011.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>HTML&amp;CSS基础知识(二)</title>
    <link href="https://seven1011.github.io/2019/11/03/HTML-CSS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E4%BA%8C/"/>
    <id>https://seven1011.github.io/2019/11/03/HTML-CSS基础知识-二/</id>
    <published>2019-11-02T18:06:37.000Z</published>
    <updated>2019-11-02T10:55:52.753Z</updated>
    
    <content type="html"><![CDATA[<pre><code>【介绍】HTML&amp;CSS必知必会，学习笔记</code></pre><a id="more"></a><h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><ul><li>最基础的网页开发语言  </li></ul><ul><li>Hyper Text Markup Language 超文本标记语言  </li></ul><p>&emsp; <strong>超文本：</strong><br>&emsp;&emsp; 超文本使用超链接的方法，将各种不同空间的文字信息组织在一起的网状文本<br>&emsp; <strong>标记语言：</strong><br>&emsp;&emsp;有标签构成的语言<br><br></p><h2 id="2-快速入门"><a href="#2-快速入门" class="headerlink" title="2. 快速入门"></a>2. 快速入门</h2><ul><li><p><strong>语法：</strong>  </p><ol><li><p>html文档的后缀名是.html或者.htm   </p></li><li><p>标签分为:  </p><pre><code>1. 围堵标签：有开始标签和结束标签。如&lt;html&gt;  &lt;/html&gt;2. 自闭合标签：开始标签和结束标签在一起。如&lt;/br&gt;  </code></pre></li><li><p>标签可以嵌套</p><pre><code>需要正确嵌套，不能你中有我，我中有你</code></pre></li><li><p>在开始标签中可以定义属性。属性是由键值对构成，值需要用引号（单双都可）引起来</p></li><li><p>html的标签不区分大小写，但是建议使用小写。</p><br></li></ol></li></ul><h2 id="3-标签学习"><a href="#3-标签学习" class="headerlink" title="3. 标签学习"></a>3. 标签学习</h2><h4 id="文件标签：构成html的最基本的标签"><a href="#文件标签：构成html的最基本的标签" class="headerlink" title="文件标签：构成html的最基本的标签"></a>文件标签：构成html的最基本的标签</h4><br><pre><code>html：html文档的根标签head：头标签。用于指定html文档的一些属性。引入外部的资源。title：标题标签body：体标签&lt;!DOCTYPE html&gt;：html5定义文档类型</code></pre><br><h4 id="文本标签：和文本有关的标签"><a href="#文本标签：和文本有关的标签" class="headerlink" title="文本标签：和文本有关的标签"></a>文本标签：和文本有关的标签</h4><br><pre><code>&lt;h1&gt; to &lt;h6&gt;：标题标签 自带换行效果&lt;p&gt;：段落标签&lt;br&gt;：换行标签&lt;hr&gt;：显示一条水平线     属性（html5不建议使用）： color（颜色） width（宽度）size（高度）align（对齐方式：center、left、right)  &lt;b&gt;：字体加粗&lt;i&gt;：斜体&lt;font&gt;(已经过时)：字体标签（属性：color、size、face（字体））&lt;center&gt;(过时标签)：文本居中</code></pre><br><h4 id="图片标签"><a href="#图片标签" class="headerlink" title="图片标签"></a>图片标签</h4><br><pre><code>img：展示图片src：存放图片的路径，一般写相对路径：以.开头       ./：代表当前目录       ../：代表上一级目录</code></pre><br><h4 id="列表标签"><a href="#列表标签" class="headerlink" title="列表标签"></a>列表标签</h4><br><pre><code>无序列表    &lt;ul&gt;：项目使用粗体远点进行标记有序列表    有序列表始于 &lt;ol&gt; 标签。每个列表项始于 &lt;li&gt; 标签自定义列表    自定义列表以 &lt;dl&gt; 标签开始。每个自定义列表项以 &lt;dt&gt; 开始。每个自定义列表项的定义以 &lt;dd&gt; 开始</code></pre><br><h4 id="连接标签"><a href="#连接标签" class="headerlink" title="连接标签"></a>连接标签</h4><br><pre><code>&lt;a&gt;</code></pre><ul><li><p>样式</p><pre><code>&lt;div&gt;：定义文档中的节&lt;span&gt;：定义文档中的节</code></pre><br></li></ul><h4 id="语义化标签：html5中为了提高程序的可读性，提供了一些标签"><a href="#语义化标签：html5中为了提高程序的可读性，提供了一些标签" class="headerlink" title="语义化标签：html5中为了提高程序的可读性，提供了一些标签"></a>语义化标签：html5中为了提高程序的可读性，提供了一些标签</h4><br><pre><code>1. &lt;header&gt;2. &lt;footer&gt;</code></pre><br><h4 id="表格标签"><a href="#表格标签" class="headerlink" title="表格标签"></a>表格标签</h4><br><pre><code>&lt;table&gt;标签用于显示一个表格属性：    border：表格的边框    width：宽度（单位px：像素）    cellpadding：定义内容和单元格的举例    cellspacing：定义单元格之间的距离。如果指定为领，则单元格的线会合为一条    bgcolor：背景色    align：对齐方式&lt;tr&gt; 表示行&lt;th&gt;：定义表头单元格&lt;td&gt; 表示列又叫单元格    width：宽度（表示：1.px   2.百分比）    align：对齐方式    valign：单元格垂直对齐    colspan：横跨两列，水平合并    bgcolor：背景色    colspan：合并列    rowspan：合并行&lt;caption&gt;：表格标题&lt;thead&gt;：表示表格头的部分&lt;tbody&gt;：表示表格头的部分&lt;tfoot&gt;：表示表格头的部分</code></pre><br><ul><li><strong>属性定义：</strong><br></li></ul><p><strong>color:</strong></p><pre><code>1. 英文单词：red，green2. rgb(值1，值2，值3)：值的范围：0~255  如：rgb(0,0,255)3. #值1值2值3：值的范围：00~FF之间。如：#FF00FF</code></pre><br><p><strong>width:</strong></p><pre><code>1. 数值：width=&quot;20&quot;，数值的单位，默认是  px(像素)2. 百分比：占相对父元素的比例</code></pre><br>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;【介绍】HTML&amp;amp;CSS必知必会，学习笔记&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="HTML" scheme="https://seven1011.github.io/categories/HTML/"/>
    
      <category term="CSS" scheme="https://seven1011.github.io/categories/HTML/CSS/"/>
    
    
      <category term="HTML" scheme="https://seven1011.github.io/tags/HTML/"/>
    
      <category term="CSS" scheme="https://seven1011.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>HTML&amp;CSS基础知识(一) </title>
    <link href="https://seven1011.github.io/2019/11/02/HTML-CSS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E4%B8%80/"/>
    <id>https://seven1011.github.io/2019/11/02/HTML-CSS基础知识-一/</id>
    <published>2019-11-02T11:02:42.000Z</published>
    <updated>2019-11-02T09:58:35.240Z</updated>
    
    <content type="html"><![CDATA[<pre><code>【介绍】HTML&amp;CSS必知必会，学习笔记</code></pre><a id="more"></a><hr><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容:"></a>主要内容:</h2><p>&emsp;&emsp;1. web概念概述<br>&emsp;&emsp;2. HTML</p><hr><h2 id="web概念概述"><a href="#web概念概述" class="headerlink" title="web概念概述"></a>web概念概述</h2><h3 id="JavaWeb："><a href="#JavaWeb：" class="headerlink" title="JavaWeb："></a>JavaWeb：</h3><p> &emsp;&emsp; 使用java语言开发基于互联网的项目<br> <br></p><h3 id="软件架构："><a href="#软件架构：" class="headerlink" title="软件架构："></a>软件架构：</h3><h4 id="1-C-S-Client-Sertver-客户端-服务器端"><a href="#1-C-S-Client-Sertver-客户端-服务器端" class="headerlink" title="1. C/S:  Client/ Sertver 客户端/服务器端"></a>1. C/S:  Client/ Sertver 客户端/服务器端</h4><p>&emsp;<strong>优点</strong></p><p>&emsp;&emsp; 1. 用户体验好</p><p>&emsp;<strong>缺点</strong></p><p>&emsp;&emsp; 1. 开发、安装、部署、维护麻烦<br> <br></p><h4 id="2-B-S-Browser-Server-浏览器-服务器端"><a href="#2-B-S-Browser-Server-浏览器-服务器端" class="headerlink" title="2. B/S: Browser/Server  浏览器/服务器端"></a>2. B/S: Browser/Server  浏览器/服务器端</h4><p>&emsp;<strong>优点：</strong></p><p>&emsp;&emsp;   1. 开发、安装、部署、维护简单</p><p>&emsp;<strong>缺点：</strong></p><p>  &emsp;&emsp;   1. 如果应用过大，用户可能受到影响</p><p>   &emsp;&emsp;     2. 对硬件要求过高</p><p><strong>详细介绍</strong><br> <br></p><p>&emsp;<strong>资源分类</strong><br> &emsp;<strong>1. 静态资源：</strong></p><p>   &emsp;&emsp; 使用静态网页开发技术发布的资源</p><p>   &emsp; 特点：</p><p>   &emsp;&emsp; 所有用户访问，得到的结果是一样的<br> <br></p><p> &emsp;<strong>2. 动态资源</strong></p><p>&emsp;&emsp;使用动态网页及时发布的资源</p><p>&emsp; 特点：</p><p>   &emsp;&emsp; 所有用户访问，得到的结果可能不一样</p><p>   &emsp;&emsp; 如果用户请求的是动态资源，那么服务器会执行动态资源，转换为静态资源，在发送给浏览器<br> <br></p><ul><li><strong>静态资源：</strong></li></ul><p>&emsp;&emsp; &emsp;&emsp; HTML:用于搭建基础网页，展示页面的</p><p>&emsp;&emsp; &emsp;&emsp; CSS:用于美化页面，布局页面</p><p>&emsp;&emsp; &emsp;&emsp; JavaScript:控制页面的元素，让页面有一些动态的效果<br> <br></p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;【介绍】HTML&amp;amp;CSS必知必会，学习笔记&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="HTML" scheme="https://seven1011.github.io/categories/HTML/"/>
    
      <category term="CSS" scheme="https://seven1011.github.io/categories/HTML/CSS/"/>
    
    
      <category term="HTML" scheme="https://seven1011.github.io/tags/HTML/"/>
    
      <category term="CSS" scheme="https://seven1011.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>后台管理项目入门(一) </title>
    <link href="https://seven1011.github.io/2019/11/02/%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E5%85%A5%E9%97%A8-%E4%B8%80/"/>
    <id>https://seven1011.github.io/2019/11/02/后台管理项目入门-一/</id>
    <published>2019-11-02T10:35:32.000Z</published>
    <updated>2019-11-02T03:08:00.068Z</updated>
    
    <content type="html"><![CDATA[<pre><code>入门（一）</code></pre><a id="more"></a><h3 id="1-项目克隆到本地："><a href="#1-项目克隆到本地：" class="headerlink" title="1.项目克隆到本地："></a>1.<strong>项目克隆到本地：</strong></h3><pre><code>git clone https://github.com/PanJiaChen/vue-element-admin.git</code></pre><h3 id="2-项目目录介绍："><a href="#2-项目目录介绍：" class="headerlink" title="2.项目目录介绍："></a>2.<strong>项目目录介绍：</strong></h3><pre><code>├── build                      // 构建相关  ├── config                     // 配置相关├── src                        // 源代码│   ├── api                    // 所有请求│   ├── assets                 // 主题 字体等静态资源│   ├── components             // 全局公用组件│   ├── directive              // 全局指令│   ├── filtres                // 全局 filter│   ├── icons                  // 项目所有 svg icons│   ├── lang                   // 国际化 language│   ├── mock                   // 项目mock 模拟数据│   ├── router                 // 路由│   ├── store                  // 全局 store管理│   ├── styles                 // 全局样式│   ├── utils                  // 全局公用方法│   ├── vendor                 // 公用vendor│   ├── views                   // view│   ├── App.vue                // 入口页面│   ├── main.js                // 入口 加载组件 初始化等│   └── permission.js          // 权限管理├── static                     // 第三方不打包资源│   └── Tinymce                // 富文本├── .babelrc                   // babel-loader 配置├── eslintrc.js                // eslint 配置项├── .gitignore                 // git 忽略项├── favicon.ico                // favicon图标├── index.html                 // html模板└── package.json               // package.json</code></pre><h3 id="2-1-components-："><a href="#2-1-components-：" class="headerlink" title="2.1 components ："></a>2.1 components ：</h3><p>&emsp;components 放置的都是全局公用的一些组件，如上传组件，富文本等等。一些页面级的组件建议还是放在各自views文件下，方便管理。</p><h3 id="2-2-store："><a href="#2-2-store：" class="headerlink" title="2.2 store："></a>2.2 store：</h3><p>  &emsp;不要为了用vuex而用vuex！</p><h3 id="2-3-webpack："><a href="#2-3-webpack：" class="headerlink" title="2.3 webpack："></a>2.3 webpack：</h3><blockquote><p>本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。</p></blockquote><p>&emsp;从 webpack v4.0.0 开始，可以不用引入一个配置文件。然而，webpack 仍然还是<a href="https://www.webpackjs.com/configuration" target="_blank" rel="noopener">高度可配置的</a>。在开始前你需要先理解四个<strong>核心概念</strong>：</p><p> &emsp;&emsp;入口(entry)<br> &emsp;&emsp;输出(output)<br> &emsp;&emsp;loader<br> &emsp;&emsp;插件(plugins)</p><h3 id="2-4-axios的封装"><a href="#2-4-axios的封装" class="headerlink" title="2.4 axios的封装"></a>2.4 axios的封装</h3><p>&emsp;<strong>目的：</strong>帮助我们简化代码和有利于后期的更新和维护。<br><br></p><p>&emsp;&emsp;&emsp;axios库经常被用在vue项目和后台交互数据方面，可以运行在浏览器端和node.js中。<br><br></p><p>&emsp;<strong>优点：</strong>拦截请求和响应、取消请求、转换json、客户端防御XSRF<br><br></p><h4 id="2-4-1-安装"><a href="#2-4-1-安装" class="headerlink" title="2.4.1 安装"></a>2.4.1 安装</h4><p>&emsp;&emsp;<code>npm install axios; // 安装axios</code></p><h4 id="2-4-2-引入"><a href="#2-4-2-引入" class="headerlink" title="2.4.2 引入"></a>2.4.2 引入</h4><p>&emsp;在src目录之中新建request文件夹，然后新建http.js和一个api.js文件。其中<br><br></p><p>&emsp;&emsp;http.js:封装我们的axios<br>&emsp;&emsp;api.js:统一管理我们的接口<br><br></p><p>&emsp;关于环境切换、设置请求超时、post请求头设置系列操作参考<a href="https://juejin.im/post/5b55c118f265da0f6f1aa354" target="_blank" rel="noopener">《vue中Axios的封装和API接口的管理》</a></p><h3 id="2-5-安装ESLint插件"><a href="#2-5-安装ESLint插件" class="headerlink" title="2.5 安装ESLint插件"></a>2.5 安装ESLint插件</h3><p>&emsp;<strong>ESLint插件+VSCode进行代码编写</strong><br><br></p><p>&emsp;对VSCode进行扩展设置  文件 &gt; 首选项 &gt; 设置 打开 VSCode 配置文件,添加如下配置：<br><br></p><pre><code>&quot;files.autoSave&quot;:&quot;off&quot;,&quot;eslint.validate&quot;: [&quot;javascript&quot;,&quot;javascriptreact&quot;,&quot;html&quot;,{ &quot;language&quot;: &quot;vue&quot;, &quot;autoFix&quot;: true }],&quot;eslint.options&quot;: {&quot;plugins&quot;: [&quot;html&quot;]}</code></pre><br>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;入门（一）&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="Element" scheme="https://seven1011.github.io/categories/Element/"/>
    
      <category term="Vue" scheme="https://seven1011.github.io/categories/Element/Vue/"/>
    
    
      <category term="Vue，Element" scheme="https://seven1011.github.io/tags/Vue%EF%BC%8CElement/"/>
    
      <category term="项目实战" scheme="https://seven1011.github.io/tags/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>webpack-dev-server 不是内部或外部命令，也不是可运行的程序或批处理文件</title>
    <link href="https://seven1011.github.io/2019/11/02/webpack-dev-server-%E4%B8%8D%E6%98%AF%E5%86%85%E9%83%A8%E6%88%96%E5%A4%96%E9%83%A8%E5%91%BD%E4%BB%A4%EF%BC%8C%E4%B9%9F%E4%B8%8D%E6%98%AF%E5%8F%AF%E8%BF%90%E8%A1%8C%E7%9A%84%E7%A8%8B%E5%BA%8F%E6%88%96%E6%89%B9%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6/"/>
    <id>https://seven1011.github.io/2019/11/02/webpack-dev-server-不是内部或外部命令，也不是可运行的程序或批处理文件/</id>
    <published>2019-11-02T10:14:36.000Z</published>
    <updated>2019-11-02T02:31:04.938Z</updated>
    
    <content type="html"><![CDATA[<pre><code>【运行报错:】webpack-dev-server 不是内部或外部命令，也不是可运行的程序或批处理文件</code></pre><a id="more"></a><hr><p>Yarn 的全称是 <strong>Yet Another Resource Negotiator</strong>，意思是“另一种资源调度器”，是一个新的快速安全可信赖的可以替代NPM的依赖管理工具，由 facebook 推出并开源。</p><hr><p>运行项目显示缺少必要的插件<br><br></p><p>运行npm下载</p><pre><code>npm install webpack-dev-server --save</code></pre><br><p>安装成功之后再次运行</p><pre><code>yarn install</code></pre><br><p>结果还是报错</p><pre><code>Error: Cannot find module &apos;webpack&apos;    at Function.Module._resolveFilename (internal/modules/cjs/loader.js:636:15)    at Function.Module._load (internal/modules/cjs/loader.js:562:25)    at Module.require (internal/modules/cjs/loader.js:690:17)    at require (internal/modules/cjs/helpers.js:25:18)    at Object.&lt;anonymous&gt; (E:\code\admin\vue-antd-admin\node_modules\webpack-dev-server\lib\Server.js:22:17)    at Module._compile (internal/modules/cjs/loader.js:776:30)    at Object.Module._extensions..js (internal/modules/cjs/loader.js:787:10)    at Module.load (internal/modules/cjs/loader.js:653:32)    at tryModuleLoad (internal/modules/cjs/loader.js:593:12)    at Function.Module._load (internal/modules/cjs/loader.js:585:3)</code></pre><p>索性删除项目目录下的<code>node_modules</code>文件夹</p><blockquote><p>npm 的工作是把将各种各样的包拉到您的计算机上，并且进行管理，这是 Nodejs 周边生态的重要体现，而node_modules文档就是存放这些安装包的地方。</p></blockquote><p>然后重新运行</p><pre><code>yarn install</code></pre><p>再运行</p><pre><code>yarn install</code></pre><p>成功运行。<br><br></p><p>解决<code>Error: Cannot find module &#39;webpack&#39;</code>可以尝试<a href="https://juejin.im/post/5cb860445188253b454b7568" target="_blank" rel="noopener">这里</a>…<br><br></p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;【运行报错:】webpack-dev-server 不是内部或外部命令，也不是可运行的程序或批处理文件&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="webpack" scheme="https://seven1011.github.io/categories/webpack/"/>
    
    
      <category term="webpack" scheme="https://seven1011.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>bash-yarn-command-not-found</title>
    <link href="https://seven1011.github.io/2019/11/02/bash-yarn-command-not-found/"/>
    <id>https://seven1011.github.io/2019/11/02/bash-yarn-command-not-found/</id>
    <published>2019-11-01T22:27:58.000Z</published>
    <updated>2019-11-02T02:22:35.811Z</updated>
    
    <content type="html"><![CDATA[<pre><code>【运行报错】：bash: yarn command not found </code></pre><a id="more"></a><h2 id="错误介绍"><a href="#错误介绍" class="headerlink" title="错误介绍"></a>错误介绍</h2><br><p>在bash中安装依赖   </p><p> &nbsp;&nbsp;&nbsp;&nbsp;    <code>yarn install</code><br><br></p><p>出现如下错误</p><p> &nbsp;&nbsp;&nbsp;&nbsp;    <code>bash: yarn: command not found</code><br><br></p><p>这是因为npm没有安装yarn，使用npm进行安装</p><p> &nbsp;&nbsp;&nbsp;&nbsp;    <code>npm install -g yarn</code></p><p><strong>解释：</strong><code>-g(-global)</code> 该命令就是以全局模式安装yarn</p><blockquote><p><strong>注意：</strong>通常情况下不建议通过npm进行安装。npm安装是非确定性的，程序包没有签名，并且npm除了做了基本的SHA1哈希之外不执行任何完整性检查，这给安装系统程序带来了安全风险。</p></blockquote><p>除此之外，还有通过适合自己操作系统的安装方法来安装yarn<br><br></p><h3 id="windows："><a href="#windows：" class="headerlink" title="windows："></a>windows：</h3><br><ol><li><p>进入<a href="https://yarnpkg.com/en/docs/install#windows-stable" target="_blank" rel="noopener">官网下载页面</a>安装(按照引导操作完成)</p><br></li><li><p>安装完成之后查看yarn版本</p><pre><code>yarn --version</code></pre></li></ol><pre><code>![](/images/picture/20191029143233-8e86a4fa-67af-478b-a2dc-edde7bc70c08.png)</code></pre><br>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;【运行报错】：bash: yarn command not found &lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="yarn" scheme="https://seven1011.github.io/categories/yarn/"/>
    
    
      <category term="yarn" scheme="https://seven1011.github.io/tags/yarn/"/>
    
  </entry>
  
  <entry>
    <title>少年的你已然成年</title>
    <link href="https://seven1011.github.io/2019/10/26/%E5%B0%91%E5%B9%B4%E7%9A%84%E4%BD%A0%E5%B7%B2%E7%84%B6%E6%88%90%E5%B9%B4/"/>
    <id>https://seven1011.github.io/2019/10/26/少年的你已然成年/</id>
    <published>2019-10-26T10:00:44.000Z</published>
    <updated>2019-10-27T05:08:56.969Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/picture/%E5%B0%91%E5%B9%B4%E7%9A%84%E4%BD%A0.jpg" alt></p><a id="more"></a><hr><p><strong>写在前面的话</strong>：有剧透，仅仅从自己的角度来谈谈《少年的你》。</p><hr><p>电影中的人物大致有这么几类。</p><h1 id="一、魏莱"><a href="#一、魏莱" class="headerlink" title="一、魏莱"></a>一、魏莱</h1><br><p><strong>好看皮囊下扭曲的灵魂。</strong>魏莱在警局接受调查，得知通知魏母之后，露出丑恶的面目。本以为会就此忏悔，结果在郑警官到家进行调查时，家中的豪华的装饰和英文奖杯以及魏母的态度，让平凡的郑警官感到无力感，凸显以陈念为代表的底层大众维护自身权利的艰辛。<br><br></p><p><strong>暴力是可以上瘾的。</strong>在受到退学处分以及小北的恐吓之后。魏反而变本加厉。是因为保利会上瘾的，所以他会在胡小蝶自杀之后，找到陈念，找到她昔日的同伴，对他们进行施暴。</p><h1 id="二、郑易"><a href="#二、郑易" class="headerlink" title="二、郑易"></a>二、郑易</h1><br>最开始在屏幕上出现的郑警官是一个血气方刚、一腔正义的年轻人。他对胡小蝶的自杀、陈念的知情不说而大声呵斥。后来有位陈念受到校园暴力而尽力地维护他。<br><p><strong>“成年后好多事情都可以忘记”</strong>后来他这样安慰陈念，成年之后确实会看淡很多事情，人随之变得大度，没有更多的空闲的时间去想一些无关紧要的事情。但是，少年时期受到的创伤确实无法弥补的，心里的阴影更是一辈子的烙印。<br><br></p><p>郑易从陈念是犯罪嫌疑人却坚持维护他去高考，<br><br></p><p>到    <strong>“你觉得会有这样的人会了对方做几十年的牢吗？”</strong><br><br></p><p><strong>“你和我不会，可是他们是少年”</strong>这样同事之间的对话。<br><br></p><p>  再到后来老杨对他说  一个好学生，一个小混混，都被你拉下水，夸赞他成熟了。<br><br></p><p>郑易也得到了成长，而他所做的是为了守护两个孩子的未来。<br><br></p><p>小北守护的是陈念的那份善良，陈年坚守的是终有一天他们可以光明正大肩并肩的周在大家上的信念。</p><h1 id="三、小北"><a href="#三、小北" class="headerlink" title="三、小北"></a>三、小北</h1><br>生活在底层的泥泞之中，原生家庭对他造成了巨大的影响。<br><p><strong>世界上有两种人，一种是挨打的，一种是打人的。</strong>他有自己对世界的见解，直到他碰到陈念。<br><br></p><p><strong>即使身处阴沟，也要仰望星空。</strong><br><br></p><p>陈年是他的逃生口。从此，他的生活才有了光和希望。所以它潜行在黑暗之中，不顾一切的想要保护陈念。<br><br></p><p><strong>“你保护世界，我保护你”</strong>陈念太干净纯洁了，即使遭受校园霸凌，她依然可以这样说。就像他在警局接受审讯时所讲：<br><br></p><p><strong>如果世界是这个样子，你还敢把你的孩子生下来吗？</strong><br><br></p><p>小贝儿守护的酒是陈念心中的那份善良。</p><h1 id="四、陈念"><a href="#四、陈念" class="headerlink" title="四、陈念"></a>四、陈念</h1><br><p>校园霸凌受害者。他一直坚信高考之后一切都会好起来，可以保妥魏莱的欺辱，帮助母亲还清债务，和小北光明正大的肩并肩走在大街上。<br><br></p><p>他和小北彼此珍惜，彼此珍重，两个人组成“共生体”，在黑暗的世界里寻找光明。<br><br></p><p>努力学习，通过高考走出小镇，是陈念的唯一念头，也是现实世界中多少学子的梦想，把希望孤注一掷的寄于高考。<br><br></p><p>陈念身上反映的不仅仅是校园暴力问题，还有教育方面的问题。<br><br></p><p>在胡晓蝶自杀之后，郑易问她你有什么朋友，他当时回答 <strong>“在这里不需要朋友。”</strong><br><br></p><p>之后的镜头更是显示高楼层走廊外面安装上的防盗窗，为了防止学生跳楼安装防盗窗的学校不在少数，这样只堵不疏的方式意义又在哪里？</p><h1 id="五、另一类就是目睹校园暴力受害者身陷沼泽之中却无动于衷的冷漠旁观者"><a href="#五、另一类就是目睹校园暴力受害者身陷沼泽之中却无动于衷的冷漠旁观者" class="headerlink" title="五、另一类就是目睹校园暴力受害者身陷沼泽之中却无动于衷的冷漠旁观者"></a>五、另一类就是目睹校园暴力受害者身陷沼泽之中却无动于衷的冷漠旁观者</h1><br><p><strong>最后，人生苦短，请你善良！希望大家都能有一美好安静又难忘的岁月…</strong><br><br></p><p>  真的很喜欢电影中人物的台词，很耐人寻味（周冬雨和易烊千玺的演技都挺赞~）</p><br><br>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/picture/%E5%B0%91%E5%B9%B4%E7%9A%84%E4%BD%A0.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="电影" scheme="https://seven1011.github.io/categories/%E7%94%B5%E5%BD%B1/"/>
    
    
      <category term="电影，感想" scheme="https://seven1011.github.io/tags/%E7%94%B5%E5%BD%B1%EF%BC%8C%E6%84%9F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>于宙：我们这一代人的困惑</title>
    <link href="https://seven1011.github.io/2019/10/24/%E4%BA%8E%E5%AE%99%EF%BC%9A%E6%88%91%E4%BB%AC%E8%BF%99%E4%B8%80%E4%BB%A3%E4%BA%BA%E7%9A%84%E5%9B%B0%E6%83%91/"/>
    <id>https://seven1011.github.io/2019/10/24/于宙：我们这一代人的困惑/</id>
    <published>2019-10-24T13:34:22.000Z</published>
    <updated>2019-10-25T10:27:37.725Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/picture/20191024141822.png" alt></p><a id="more"></a><p>原文地址：<a href="http://blog.sina.com.cn/s/blog_70e965880102ve5v.html" target="_blank" rel="noopener">JOIN创业实战笔记的博客</a><br>视频链接：<a href="https://link.zhihu.com/?target=http%3A//v.qq.com/boke/page/e/0/9/e0143xi01p9.html" target="_blank" rel="noopener">   【TEDxDUFE】于宙  </a></p><hr><p><strong>导读</strong>：本文是于宙在TEDx大会上的演讲，这篇文章有点长，不过非常值得你花20分钟把它看完。本周如果只能推荐一篇文章，那么强烈建议你读读这一篇，“一个有故事的大叔说的实在话”。</p><hr><p><strong>以下是演讲全文：</strong><br><br><br>大家下午好，</p><p>很荣幸能够参加本次TEDx大会，非常感谢东北财经大学TED团队和华臣影城为我们提供这样一个交流的机会。<br><br><br><strong>自我介绍</strong><br><br><br>我是大连人，高中就读于大连市二十四中。因为当时学习十分不努力，所以高中毕业之后选择了出国留学，这其实是很多本科出国留学的人不能说的秘密，辗转了几个学校，最终毕业于美国印第安纳大学凯利商学院，主修投资和金融衍生品。上学的时候迷恋炒股，学习依旧散漫，没能成为一个“放弃了华尔街的高薪工作毅然回国”海归精英，真的颇为遗憾，因为实在没有什么华尔街的公司愿意要我。碰巧的是，毕业前两年股市和外汇的行情比较好，赚到了一点点资本，于是我决定回国做点生意。现在在大连从事餐饮行业，目前拥有万达广场的不出二品，大都会，福佳新天地，奥林匹克广场的莉蒂娅城堡4家芝士蛋糕店，青泥洼桥2路车站，长春路百盛，和即将开业的罗斯福地下的乔东家脆皮火烧三家火烧店。<br><br><br><strong>引言</strong><br><br><br>大学毕业之后第一次面对这么多人做演讲，坦率地说，非常的紧张。虽然年轻的时候我曾经畅想过很多次，功成名就之后能像我曾经的那些偶像一样和年轻的朋友们分享一下我是如何从一无所有走上人生巅峰的经验，然后语重心长的告诉大家，人活着不能像一根草而是要像一棵树，能走到金字塔顶端的只有雄鹰和蜗牛两种动物，我的成功你也可以复制等等。可是过了26岁之后我忽然意识到一个严肃的问题，就是自己的一生未必会取得很大的成就啊，所以当TEDxDUFE团队找到我说没关系即便你只是一个开小吃店的，我们也愿意为你提供这样一个和很多人交流思想的机会时，我的心情是多么地激动。因为公司还没上市，所以小草大树，雄鹰蜗牛，睡地板捡易拉罐这样的故事还不到说的时候。今天，只想和大家分享几个困扰了我和我身边的一些朋友十几年的问题，和在经历了一些变故和挫折后，我对这些问题的看法。<br><br><br><strong>努力奋斗真的能实现梦想吗？</strong><br><br><br>大家现在可以想象一下汪峰老师坐在转椅上，深情的望着你对你说，“你的梦想是什么？”周星驰老师的那句“做人如果没有梦想，和咸鱼有什么区别？”据说也激励了几代人。梦想这个东西是如此的重要，简直就是人生的一盏明灯。成功的人们成功的原因各不相同，但他们都不会忘记告诉你，无论到什么时候，都不曾忘记梦想，是他们成功的首要原因。以至于我们这一代人对于人生意义的最通常的理解，就在于坚持梦想并最终实现它。可很少有人愿意面对的一件事情是，大部分人的梦想永远，没错，永远都实现不了。  </p><p>你没听错，大部分人的梦想永远都实现不了。</p><p>先和大家分享一个我之前的梦想。上大学的时候我热衷于各式各样的赌博游戏，是学校旁边赌场的常客。我赌徒生涯的起点源于赌场里最基本游戏轮盘赌，轮盘上1到36个数字和两个0，赔率是1赔36。1到36分为红黑两色，押注红黑的赔率是1赔1。作为一个合格的接受过九年义务教育的人都知道，每一次轮盘开始转动的那一刻，都是一次纯粹的独立随机事件。但是赌博这件事情的魅力就在于，当你真正身处赌场，看到已经连续4次开出红色的时候，几乎所有人都会想把筹码压在黑色的那一面。而我当时的梦想，就是破译这其中的奥秘。我最初的策略非常简单，当连续三次开出奇数，就押注偶数，连续三次红色，就押注黑色。难以置信的事情发生了，在我严格的执行这个策略的情况下，前几次去赌场不但全身而退，每次都还赚了不少，以至于我产生了一种幻觉，也许游戏是有规律可循的，我已经看到了人生巅峰就在不远处向我招手。当然最终的结尾你们一定想到了，在经历过连续18个偶数，连续开出21次黑色后，我把之前赚到的钱都乖乖地还给了赌场。</p><p>后来我知道，我那个愚蠢的梦想叫做赌徒谬论，就不具体展开讲了。但它对我意义深刻，我终于明白了在纯粹的随机事件面前，一切规律都是无谓的。</p><p>生活中的事情有极个别和轮盘赌一样，属于纯粹的随机事件，比如双色球。可是几乎每一个中了双色球的人都会告诉你啊，他们花了多少精力去钻研往期号码，研究历史规律，付出了多少辛勤的努力最终获得了成功。实际上，即使是纯粹由随机性主导的事情，只要参与的人的基数足够大，小概率事件总会发生。有趣的是，几乎所有在随机事件中的受益者，都会把这完全由运气决定的结果归功于自己的努力上。不仅仅是参与者本身，旁观者也会这么认为。再比如，中国好声音的冠军嘛。<br><br><br><strong>我们生活中遇到的所有事情基本可以分为三类，第一类纯粹由随机性决定，比如布朗运动和轮盘赌博，第二类纯粹由能力决定，比如英语六级考试，110米栏之类。第三类，也是我们最常遇到的，由能力和随机性共同决定，比如创业，投资，恋爱或是梦想。</strong><br><br><br>我对励志大师们总告诉年轻人要不惜一切代价追逐梦想感到深深厌倦的原因就在于，大多数人的梦想虽然不是纯粹的双色球，但也绝对是由随机性主导的。在强大的随机性面前，付出再多辛勤的汗水，就好比夜以继日蹲在轮盘赌旁边渴望参透其中规律。前面说到中国好声音的冠军，张碧晨的那一句you are my destiny，听得我也是醉了。但毕竟那一刻，中国又有多少唱歌唱的和她一样好甚至更好的姑娘，如果真把成为好声音冠军作为一生的梦想，一生中都得在痛苦中度过。我个人很喜欢黄渤，但绝对不会用黄渤作为例子去激励一个我这种长相差的年轻人不惜一切代价去追逐演员梦，注意是不惜一切代价。因为无论是唱歌还是演戏，再多的努力也只能让你变得很优秀，它们并不存在可以量化的评判标准，想成为万众瞩目明星，随机性的重要程度都远远大于实力。<br><br><br>我想，<strong>一个人在年轻的时候，做的每一件事情，能清楚的区分其中随机性所占的比例并能心平气和的接受它，在我看来就是最宝贵的财富。</strong><br><br><br>那么在你的梦想中，运气又扮演了多重要的角色呢？当你深深的感知到这件事情的随机性也许不会青睐与你，是否还愿意坚持下去呢？对我而言，梦想永远是值得执着追求的，但我可以无比心平气和的接受，它就是永远无法实现。<br><br><br><strong>既然连梦都实现不了，还有什么事情值得努力呢？</strong><br><br><br>去年这个时候，我发过一条微博。</p><p><strong>这些年我一直提醒自己一件事情，千万不要自己感动自己。大部分人看似的努力，不过是愚蠢导致的。什么熬夜看书到天亮，连续几天只睡几小时，多久没放假了，如果这些东西也值得夸耀，那么富士康流水线上任何一个人都比你努力多了。人难免天生有自怜的情绪，唯有时刻保持清醒，才能看清真正的价值在哪里。</strong><br> <br><br>这段话在网上的疯传，是我始料不及的。更出乎我意料之外的是，我在评论中看到了相当一部分的骂声，还有人认真的给我写下了相当深刻的话，“你在拥有自己的光亮时不要吹熄别人的蜡烛，你不能因为你自己的不喜欢就否定别人。”很莫名其妙是吧，即使你刚刚听完我上一段关于随机性的看法，你也会知道，我从来都不觉得努力是一件无所谓的事情。恰恰相反，我一直相信，在能力没达到一定程度之前，你连面对随机性的资格都没有啊。张碧晨能拿好声音冠军自然离不开运气，但换成杨幂，评委不但不会转身可能直接撒腿就跑了。</p><p>可现在问题来了，那究竟什么才算是有价值的努力？这可以从我那条微博说起。去年这个时候我和朋友在琢磨去大庆做点服装生意，决定去考察几个商场。我当时住在北京，因为之前晚上和朋友在外面玩的比较尽兴回到家里已经比较晚了，担心睡觉睡过头会错过航班，那晚上就直接在沙发上靠了一晚。那是我第一次去哈尔滨，十一月份已经很冷了，衣服拿的不足，下了飞机冻得头疼。又因为没有提前订票，到了哈尔滨之后才买的火车票，发现就只剩站票了。于是，当我一晚上没睡，冻得头晕眼花，又在绿皮火车上站了两个多小时之后，抵达大庆的那一瞬间我觉得自己实在是太不容易了，将来必须要写进回忆录里面。可是，回头仔细一想，这些所谓的“努力”对我最终把那个服装生意做好，没有半毛钱关系。更何况，如果我前一天晚上能早点上床睡觉，多准备点衣服，提前在网上把火车票订好，完全可以舒舒服服的达到同样的目的。我的那次经历像是自己二十多年生活中很多事情的缩影，沉溺在对结果没有直接帮助只是因为自己遭受了一些痛苦的行为中，误以为那就是努力。<br><br><br><strong>当我终于意识到我并不是唯一曾经把无意义的消耗当作努力的时候，忽然发现，原来生活中我觉得很努力的人，也许没那么勤奋，如果在正确的方向上坚持行动，超过他们也并不困难。</strong><br><br><br>因为我们这一代人对于勤奋和努力的理解，几乎清一色的来自于学校，更精确的说，在前二十多年的生活中，我们眼中最努力的人，就是那些最能拼命看书和做题的人。实际上，这种理解是极其片面而幼稚的，因为看书和做题本身，都是为了一个极其鲜明的目的而存在的，就是通过考试。这种勤奋的付出极其纯粹，更多的复习时间，更高的复习强度，一般而言，都可以直接的提高考试的分数，它们之间的联系鲜明而直接，每个人都看的懂。<br><br><br><strong>但生活的美妙之处却在于，很多事情在我们没做到一定程度之前，是完全没法理解的。</strong><br><br><br>这就好比学英语，十几年漫长的岁月里我都在幻想，要通过多么复杂的流程，多么精密的设计，多么全面的涉及和多么不可思议的努力，终于有那么一天，或许就我就能因为前期的那些无懈可击的学习，说一口比较流利的英语，像说中文一样，可以边说边想，而不是说每一句话之前设计它的句式时态词汇然后在心里复述几遍再看上去流利的背诵出来。谁不是这么设想的呢？可惜，它不仅从来没有实现，并且让我看不到有任何实现的趋势，对于每一个设立目标的人来说，没有比这更痛苦的感受。</p><p>但是在去了美国两年左右的时间之后，我忽然发现自己可以已经毫无障碍的说一口流利的英语了。这并非我采用了什么新的学习方法，而是因为去了印第安纳之后身边中国人很少，在没有选择的情况下，只能被迫用英语去交流和表达，在这个过程中我并没有认真想过自己每天进步了多少，也没有阶段性的检验学习效果，只是不停的去听和说，因为没有选择嘛。直到两年多后的忽然有一天我才意识到，咦，自己好像真的已经可以了。但是我确实无法总结出来是如何一步一步做到的，只是那两年的时间，我一直都在很不情愿地用英语去生活嘛。<br><br><br><strong>一个人能获得的最可贵的能力，都和掌握一门语言一样，你所付出的努力不是能够获得即时回馈的，甚至在很长的一段时间内没有任何收获，直到积累到了一定的阶段后，忽然爆发出惊人的力量，连你自己都不清楚这一切是如何发生的。比如锻炼身体，读书写作，或者是做生意。当你经历了足够的量变终于引起质变时拥有的技能，大部分人是终身难以企及的，不是因为他们太笨，恰恰相反，因为他们都太聪明了。</strong><br><br><br>触发人类行动的最基本原理被称为反射，我们是需要即时回馈的物种。所以绝大多数人对于世界的理解度是线性的，但更多情况下，事物却是以漫长的潜伏震荡后爆发突破的形式发展的。我现在时常觉得，人在少年时期更容易掌握语言，乐器，美术这些成年后很难学的技艺，并非那小时候就是天资聪颖，而是小孩子很少会一个星期质疑一次自己收获了多少，都是闷头一练就是好几年，直到学会了才知道哦自己已经会了。只有聪明的成年人，才相信1本书读懂易经，10句话揭秘马云的成功之道，30天成为吉他高手的故事。<br><br><br>简而言之，<strong>现实生活中，付出和结果之间往往没有那么立竿见影。在离开学校之后，当我们遇到的很多事情不再像做题和考试之间联系的那么紧密的时候，很多人的付出都是浅尝辄止的。而最可贵的努力，是选择一个正确的方向，那些无法立即获得回报的事情，依然能付出十年如一日的专注和热情，最终的结果也许不足以让你独孤求败，但足以出类拔萃.</strong><br><br><br><strong>人这一生中是否有一个节点，过了之后一切都会好起来？</strong><br><br><br>前面说了这么多，谈论的都与目标和实现目标有关。仔细想想，我们的一生好像都是在实现目标中挣扎着度过的。上初中的时候，老师告诉你，中考的淘汰率是最高的，只要闯过去，上了高中一切就好了。但上了高中的时候发现不是那么回事嘛，高中老师又说了啊，考上大学就进了天堂。于是你考上了大学，依然空虚迷茫各种草样年华，父母老师又告诉你，找到工作就好了。工作之后发现烦恼和忧虑依然都在，女朋友给你看马云的故事，告诉你等你事业有成就好了……</p><p>你发现了吗，其实人这一辈子的每一个阶段都有新的痛苦和顾虑，周而复始，生生不息。绝对不会因为你考上大学，事业有成，迎娶了女神就从此happilyever after。但每一个阶段也有每一个阶段的快乐，无法替代。生活不是安徒生童话也不是好莱坞电影，从出生的那一刻起直到生命的尽头，都不存在什么节点，过去了之后一切幸福美满无忧无虑。<br><br><br><strong>每一段岁月都有它存在的价值，没有高低贵贱之分，都不应该被辜负。而我能想到的人这一生能做的最愚蠢的事情，就是把全部人生的希望都孤注一掷到未来的某个节点上，而忽略了生活本身应有的乐趣。哪怕你以后真正实现了那个执念中的目标，才会发现它远远没你想的那么美好。</strong>年轻的时候和哥们在操场上打篮球喝可乐的快乐，是以后高尔夫会球所品里红酒替代不了的。尤其男生，千万不要总想着等将来老子有钱了如何如何，且不说你以后很可能不会太有钱，而且相信我，就是有钱了也真的不能怎么样。<strong>生命就在每天的生活里，一切执念都是虚妄，和身边的人愉快相处，认真安排好每一天的活动，用心去感受每一天的心境，就是生活的意义本身。</strong>这其实是我今天最想分享给你们的事情。<br><br></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/picture/20191024141822.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="TED" scheme="https://seven1011.github.io/categories/TED/"/>
    
    
      <category term="TED" scheme="https://seven1011.github.io/tags/TED/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot JDBC 连接数据库</title>
    <link href="https://seven1011.github.io/2019/10/18/Spring-Boot-JDBC-%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>https://seven1011.github.io/2019/10/18/Spring-Boot-JDBC-连接数据库/</id>
    <published>2019-10-17T19:16:55.000Z</published>
    <updated>2019-10-23T13:58:31.744Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/picture/20191017140251.jpg" alt></p><a id="more"></a><pre><code>springboot jdbc连接数据库的具体操作步骤以及在操作过程遇到的问题解决参考来源：黑马程序员教程javaEE 《Spring Boot基础课件》</code></pre><h2 id="JDBC连接数据库"><a href="#JDBC连接数据库" class="headerlink" title="JDBC连接数据库"></a>JDBC连接数据库</h2><h3 id="1-pom-xml配置maven依赖"><a href="#1-pom-xml配置maven依赖" class="headerlink" title="1. pom.xml配置maven依赖"></a>1. pom.xml配置maven依赖</h3><pre><code>&lt;!-- MYSQL --&gt;&lt;dependency&gt;&lt;groupId&gt;mysql&lt;/groupId&gt;&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- Spring Boot JDBC --&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><h3 id="2-进行属性文件的配置"><a href="#2-进行属性文件的配置" class="headerlink" title="2. 进行属性文件的配置"></a>2. 进行属性文件的配置</h3><pre><code>spring.datasource.url=jdbc:mysql://127.0.0.1:3306/testspring.datasource.username=rootspring.datasource.password=rootspring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.max-idle=10spring.datasource.max-wait=10000spring.datasource.min-idle=5spring.datasource.initial-size=5</code></pre><h3 id="3-项目和包"><a href="#3-项目和包" class="headerlink" title="3. 项目和包"></a>3. 项目和包</h3><p> <img src="/images/picture/20191017144544.jpg" alt></p><h3 id="4-java代码"><a href="#4-java代码" class="headerlink" title="4. java代码"></a>4. java代码</h3><h4 id="4-1-SpringbootJdbcApplication-java"><a href="#4-1-SpringbootJdbcApplication-java" class="headerlink" title="4.1 SpringbootJdbcApplication.java"></a>4.1 SpringbootJdbcApplication.java</h4><pre><code>package com.seven;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class SpringbootJdbcApplication {    public static void main(String[] args) {        SpringApplication.run(SpringbootJdbcApplication.class, args);    }}</code></pre><h4 id="4-2-OneController-java"><a href="#4-2-OneController-java" class="headerlink" title="4.2 OneController.java"></a>4.2 OneController.java</h4><pre><code>package com.seven.controller;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;@Controllerpublic class OneController {     @Autowired    private JdbcTemplate jdbcTemplate;     @RequestMapping(&quot;/&quot;)    @ResponseBody    public String index(){        String sql = &quot;insert into user (id,name) values (1,&apos;zhangsan&apos;)&quot;;        jdbcTemplate.execute(sql);        System.out.println(&quot;执行完成&quot;);        return &quot;hello spring boot&quot;;    }}</code></pre><h3 id="5-运行项目"><a href="#5-运行项目" class="headerlink" title="5. 运行项目"></a>5. 运行项目</h3><pre><code>运行SpringApplication.java中的main()方法</code></pre><h3 id="6-进行访问"><a href="#6-进行访问" class="headerlink" title="6. 进行访问"></a>6. 进行访问</h3><pre><code>访问本地端口：[http://localhost:8080/](http://localhost:8080/]</code></pre><h3 id="7-报错：java-sql-SQLNonTransientConnectionException"><a href="#7-报错：java-sql-SQLNonTransientConnectionException" class="headerlink" title="7. 报错：java.sql.SQLNonTransientConnectionException"></a>7. 报错：java.sql.SQLNonTransientConnectionException</h3><pre><code>Failed to obtain JDBC Connection; nested exception is java.sql.SQLException: The server time zone value &apos;?????????&apos; is unrecognized or represents more than one time zone. You must configure either the server or JDBC driver (via the serverTimezone configuration property) to use a more specifc time zone value if you want to utilize time zone support.</code></pre><h3 id="8-解决办法"><a href="#8-解决办法" class="headerlink" title="8. 解决办法"></a>8. 解决办法</h3><pre><code>在 application.properties 文件 url 后面添加 ?serverTimezone=UTCspring.datasource.url=jdbc:mysql://localhost:3306/testapplication.在此运行，访问，显示成功。</code></pre><h3 id="9-未解决时可能出现的问题"><a href="#9-未解决时可能出现的问题" class="headerlink" title="9. 未解决时可能出现的问题"></a>9. 未解决时可能出现的问题</h3><pre><code>- application.properties文件配置的url其中：Mysql6.0需要的驱动类名为：com.mysql.cj.jdbc.Driver,而Mysql5需要的驱动类名为：com.mysql.jdbc.Driver- 数据库链接地址错误（&quot;/&quot;的数量）:spring.datasource.url=jdbc:mysql://127.0.0.1:3306/yourDB_name- 数据库账号密码错误- 数据库未启动或者无权访问，需要增加权限</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/picture/20191017140251.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="springboot" scheme="https://seven1011.github.io/categories/springboot/"/>
    
      <category term="JDBC" scheme="https://seven1011.github.io/categories/springboot/JDBC/"/>
    
    
      <category term="JDBC" scheme="https://seven1011.github.io/tags/JDBC/"/>
    
      <category term="springboot" scheme="https://seven1011.github.io/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>MySQL多表&amp;事物</title>
    <link href="https://seven1011.github.io/2019/10/13/MySQL%E5%A4%9A%E8%A1%A8-%E4%BA%8B%E7%89%A9/"/>
    <id>https://seven1011.github.io/2019/10/13/MySQL多表-事物/</id>
    <published>2019-10-13T12:50:26.000Z</published>
    <updated>2019-10-27T14:23:08.895Z</updated>
    
    <content type="html"><![CDATA[<pre><code>【介绍】MySQL多表和事物知识点总结</code></pre><a id="more"></a><h1 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h1><pre><code>1. 多表查询2. 事务3. DCL</code></pre><h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><ul><li><p>查询语法</p><pre><code>select    列名列表from    表名列表where....</code></pre></li></ul><pre><code>笛卡尔积：     有两个集合A,B .取这两个集合的所有组成情况。     要完成多表查询，需要消除无用的数据</code></pre><ul><li>多表查询的分类：</li></ul><ol><li><p>内连接查询：</p><pre><code>1. 隐式内连接：使用where条件消除无用数据2. 显式内连接：         语法： select 字段列表 from 表名1 [inner] join 表名2 on 条件3. 内连接查询：            1. 从哪些表中查询数据            2. 条件是什么            3. 查询哪些字段</code></pre></li><li><p>外链接查询：</p><pre><code>1. 左外连接：         语法：select 字段列表 from 表1 left [outer] join 表2 on 条件；         查询的是左表所有数据以及其交集部分。2. 右外连接：         语法：select 字段列表 from 表1 right [outer] join 表2 on 条件；         查询的是右表所有数据以及其交集部分。</code></pre></li><li><p>子查询：</p><pre><code>概念：查询中嵌套查询，称嵌套查询为子查询。   -- 查询工资最高的员工信息   -- 1 查询最高的工资是多少 9000   SELECT MAX(salary) FROM emp;   -- 2 查询员工信息，并且工资等于9000的   SELECT * FROM emp WHERE emp.`salary` = 9000;   -- 一条sql就完成这个操作。子查询   SELECT * FROM emp WHERE emp.`salary` = (SELECT MAX(salary) FROM emp);</code></pre><ul><li><p>子查询不同情况</p><pre><code>1. 子查询的结果是单行单列的：     子查询可以作为条件，使用运算符去判断。 运算符： &gt; &gt;= &lt; &lt;= =    -- 查询员工工资小于平均工资的人    SELECT * FROM emp WHERE emp.salary &lt; (SELECT AVG(salary) FROM emp);2. 子查询的结果是多行单列的：    * 子查询可以作为条件，使用运算符in来判断    -- 查询&apos;财务部&apos;和&apos;市场部&apos;所有的员工信息    SELECT id FROM dept WHERE NAME = &apos;财务部&apos; OR NAME = &apos;市场部&apos;;    SELECT * FROM emp WHERE dept_id = 3 OR dept_id = 2;    -- 子查询    SELECT * FROM emp WHERE dept_id IN (SELECT id FROM dept WHERE NAME = &apos;财务部&apos; OR NAME = &apos;市场部&apos;);3. 子查询的结果是多行多列的：    * 子查询可以作为一张虚拟表参与查询    -- 查询员工入职日期是2011-11-11日之后的员工信息和部门信息    -- 子查询    SELECT * FROM dept t1 ,(SELECT * FROM emp WHERE emp.`join_date` &gt; &apos;2011-11-11&apos;) t2    WHERE t1.id = t2.dept_id;    -- 普通内连接    SELECT * FROM emp t1,dept t2 WHERE t1.`dept_id` = t2.`id` AND t1.`join_date` &gt;  &apos;2011-11-11&apos;</code></pre></li></ul></li></ol><br><p>视频课程笔记</p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;【介绍】MySQL多表和事物知识点总结&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="MySQL" scheme="https://seven1011.github.io/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://seven1011.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL约束重点</title>
    <link href="https://seven1011.github.io/2019/10/10/MySQL%E7%BA%A6%E6%9D%9F%E9%87%8D%E7%82%B9/"/>
    <id>https://seven1011.github.io/2019/10/10/MySQL约束重点/</id>
    <published>2019-10-10T14:20:46.000Z</published>
    <updated>2019-10-23T13:42:15.527Z</updated>
    
    <content type="html"><![CDATA[<pre><code>【介绍】MySQL约束知识点总结</code></pre><a id="more"></a><h1 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h1><pre><code>1. DQL：查询语句    排序查询    聚合函数    分组查询    分页查询2. 约束3. 多表之间的关系4. 范式5. 数据库的备份和还原</code></pre><h1 id="DQL：查询语句"><a href="#DQL：查询语句" class="headerlink" title="DQL：查询语句"></a>DQL：查询语句</h1><pre><code>1. 排序查询    * 语法：order by 子句        * order by 排序字段1 排序方式1 ，  排序字段2 排序方式2...    * 排序方式：        * ASC：升序，默认的。        * DESC：降序。    * 注意：        * 如果有多个排序条件，则当前边的条件值一样时，才会判断第二条件。2. 聚合函数：  将一列数据作为一个整体，进行纵向的计算    1.count：计算个数        1.一般选择非空的列：主键        2.count(*)    2.max：计算最大值    3.min：计算最小值    4.sum：计算和    5.avg：计算平均值    *注意：聚合函数的计算，排除null值       解决方案：           1.选择不包含非空的列进行计算           2.IFNULL函数3.分组查询    1.语法： group by  分组字段    2.注意：        1.分组之后查询的字段：分组查询、聚合函数        2.where和having的区别            (1) where在分组之前进行限定，如不满足条件，则不能参与分组                having在分组之后进行限定，如不满足，则不会被查询出来            (2) where后不可以根据核函数，having可进行聚合函数判断  4.分页查询    1.语法：limit开始的索引，每页查询的条数    2.公式：开始的索引 = （当前的页码 - 1） * 每页显示的条数    --每页显示3条记录            SELECT*FROM student LIMIT 0,3  --第1页            SELECT*FROM student LIMIT 3,3  --第2页            SELECT*FROM student LIMIT 6,3  --第3页    3.limit是一个MySql的&quot;方言&quot;</code></pre><h1 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h1><pre><code>* 概念：对表中的数据进行限定，保证数据的正确性、有效性和完整性* 分类：    1.主键约束    2.非空约束    3.唯一约束    4.外键约束   *非空约束：not null 值不能为null       1.创建表示添加约束           2.CREATE TABLE Stu(               id TNT;               NAME VARCHAR(20) NOT NULL --name为非空               )        2.创建表完后添加非空约束            ALTER TABLE Stu MODIFY NAME VARCHAR(20) NOT NULL;        3.删除name的非空约束            ALTER TABLE Stu MODIFY NAME VARCHAR(20);    *唯一约束：unique， 只不能重复        1.创建表示，添加唯一约束            CREATE TABLE stu(            id INT,            phone_number VARCHAR(20) UNIQUE -- 添加了唯一约束            );        * 注意mysql中，唯一约束限定的列的值可以有多个null        2.删除唯一约束            ALTER TABLE stu DROP INDEX phone_number;        3.再创建表之后添加唯一约束            ALTER TABLE stu MODIFY phone_number VARCHAR(20) UNIQUE;    *主键约束：primary key        1.注意：            1.含义：非空且唯一            2.一张表只能有一个字段为主键            3.主键就是表中记录的唯一标识        2.在创建表时，添加主键约束            creat table stu(            id int primary key auto_increment, --给id添加主键约束            name varchar(20)            )        3.删除主键            ALTER TABLE stu DROP PRIMARY KEY;        4.自动增长            1.概念：如果某一列是数值类型的，使用auto_increment 可以来完成值得自动增长            2.在创建表时，添加主键约束，并且完成主键自增长                    create table stu(                        id int primary key auto_increment,-- 给id添加主键约束                        name varchar(20)                    );            3. 删除自动增长                ALTER TABLE stu MODIFY id INT;            4. 添加自动增长                ALTER TABLE stu MODIFY id INT AUTO_INCREMENT;        *外键约束：foregin key，让表与表产生关系，从而保证数据的正确性。            1.在创建表时，可以添加外键                *语法                    create table 表名(                        ...                        外键列                        constraint 外键名称 foreign key (外键列名称) references 主表名称(主表列名称                        );            2.删除外键                ALTER TABLE 表名 DROP FOREIGN KEY 外键名称;            3.创建表之后，添加外键                ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称);            4.级联操作                1.添加级联操作：                    语法：ALTER TABLE 表名 ADD CONSTRAINT 外键名称                                     FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称) ON UPDATE CASCADE ON DELETE CASCADE  ;                2.分类                    1.级联更新：ON UPDATE CASCADE                    2.级联删除：ON DELETE CASCADE</code></pre><h1 id="数据库的设计"><a href="#数据库的设计" class="headerlink" title="数据库的设计"></a>数据库的设计</h1><pre><code>1.多表之间的关系    1.分类        1.一对一：        2.一对多        3.多对多    2.实现关系：        1.一对多（多对一）            实现方式：在多的一方建立外键，指向一的一方的主键        2.多对多            实现方式：多对多关系实现需要借助第三张中间表。中间表至少包含两个字段，这两个字段作为第三张表的外键，分别指向两张表的主键        3. 一对一(了解)：            实现方式：一对一关系实现，可以在任意一方添加唯一外键指向另一方的主键。2.数据库设计的范式    *概念：设计数据库时，需要遵循的一些规范。要遵循后边的范式要求，必须先遵循前边的所有范式要求    设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。    目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。    * 几个概念：                1. 函数依赖：A--&gt;B,如果通过A属性(属性组)的值，可以确定唯一B属性的值。则称B依赖于A                    例如：学号--&gt;姓名。  （学号，课程名称） --&gt; 分数                2. 完全函数依赖：A--&gt;B， 如果A是一个属性组，则B属性值得确定需要依赖于A属性组中所有的属性值。                    例如：（学号，课程名称） --&gt; 分数                3. 部分函数依赖：A--&gt;B， 如果A是一个属性组，则B属性值得确定只需要依赖于A属性组中某一些值即可。                    例如：（学号，课程名称） -- &gt; 姓名                4. 传递函数依赖：A--&gt;B, B -- &gt;C . 如果通过A属性(属性组)的值，可以确定唯一B属性的值，在通过B属性（属性组）的值可以确定唯一C属性的值，则称 C 传递函数依赖于A                    例如：学号--&gt;系名，系名--&gt;系主任                5. 码：如果在一张表中，一个属性或属性组，被其他所有属性所完全依赖，则称这个属性(属性组)为该表的码                    * 主属性：码属性组中的所有属性                    * 非主属性：除过码属性组的属性    * 分类：            1.第一范式（1NF）：每一列都是不可分割的原子数据项            2.第二范式（2NF）：在1NF的基础上，非码属性必须完全依赖于码（在1NF基础上消除非主属性对主码的部分函数依赖）                3.第三范式（3NF）：在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖）</code></pre><h1 id="数据库的备份和还原"><a href="#数据库的备份和还原" class="headerlink" title="数据库的备份和还原"></a>数据库的备份和还原</h1><pre><code>1.命令行：    *语法：        · 备份： mysqldumo -u用户名 -p密码数据库名称 &gt; 保存的路径        · 还原：            1. 登录数据库            2. 创建数据库            3. 使用数据库            4. 执行文件。source 文件路径2.图形化工具</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;【介绍】MySQL约束知识点总结&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="MySQL" scheme="https://seven1011.github.io/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://seven1011.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>hexo博客next主题--不蒜子计数不显示问题解决办法</title>
    <link href="https://seven1011.github.io/2019/10/09/hexo%E5%8D%9A%E5%AE%A2next%E4%B8%BB%E9%A2%98-%E4%B8%8D%E8%92%9C%E5%AD%90%E8%AE%A1%E6%95%B0%E4%B8%8D%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <id>https://seven1011.github.io/2019/10/09/hexo博客next主题-不蒜子计数不显示问题解决办法/</id>
    <published>2019-10-09T12:51:23.000Z</published>
    <updated>2019-10-23T13:33:56.196Z</updated>
    
    <content type="html"><![CDATA[<pre><code>【介绍】hexo博客使用next主题时，开启不蒜子计数不显示问题解决办法</code></pre><a id="more"></a><p>最新的next主题中支持了三方插件<code>busuanzi</code>，在主题配置文件中搜索<code>busuanzi</code>，会看到开启不蒜子的按钮。<br><img src="/images/picture/kaiqibusuanzi.jpg" alt="示意图"><br>开启之后部署三连，发现下方的统计图标并没有出现，然后找解决办法，发现网上大多数对于next主题的解决办法修改到期的域名。打开<code>/themes/next/layout/_partials/analytics/busuanzi-counter.swig</code>文件，可以观察到，在新版本next主题中的<code>不蒜子</code>域名已经进行更新:<br><code>&lt;script async src=&quot;https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;</code><br>页面却不显示。<br><img src="/images/picture/busuanzijishubuxianshi.jpg" alt><br>查看html代码<br><img src="/images/picture/busuanzicount_1.jpg" alt><br>可以看到<code>style</code>设置为none，在<code>busuanzi-counter.swig</code>将<code>style=&quot;display:none&quot;</code>删除，发现显示还是没有恢复，最后删除同文档中的id即下图红框中内容<br><img src="/images/picture/busuanzicount_2.jpg" alt><br>重新部署后，即可得到最终得结果。<br><img src="/images/picture/busuanzicount_3.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;【介绍】hexo博客使用next主题时，开启不蒜子计数不显示问题解决办法&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="https://seven1011.github.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://seven1011.github.io/tags/hexo/"/>
    
      <category term="blog" scheme="https://seven1011.github.io/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>MySQL基础知识总结</title>
    <link href="https://seven1011.github.io/2019/10/08/MySQL%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    <id>https://seven1011.github.io/2019/10/08/MySQL基础知识总结/</id>
    <published>2019-10-07T19:39:35.000Z</published>
    <updated>2019-10-23T13:42:11.551Z</updated>
    
    <content type="html"><![CDATA[<pre><code>【介绍】MySQL基础知识的总结</code></pre><a id="more"></a><h1 id="1、数据库的基本概念"><a href="#1、数据库的基本概念" class="headerlink" title="1、数据库的基本概念"></a>1、数据库的基本概念</h1><ul><li>维基百科定义<blockquote><p>所谓“数据库”系以一定方式储存在一起、能予多个用户共享、具有尽可能小的冗余度、与应用程序彼此独立的数据集合。一个数据库由多个表空间（Tablespace）构成。</p></blockquote></li></ul><ol><li><p>数据库的英文单词：</p><pre><code>DateBase  简称  DB</code></pre></li><li><p>什么是数据库</p><pre><code>用于存储和管理数据的仓库</code></pre></li><li><p>数据库的特点  </p><pre><code>1. 持久化存储数据的，其实数据库就是一个文件系统2. 方便存储和管理数据的3. 使用统一的方式操作数据库  --SQL</code></pre></li></ol><h1 id="2、MySQL数据库软件"><a href="#2、MySQL数据库软件" class="headerlink" title="2、MySQL数据库软件"></a>2、MySQL数据库软件</h1><ul><li>常见的数据库软件  mysql、oracle、sqlserver、sqlite、postgreSQL等  </li><li>安装–卸载–配置</li></ul><h1 id="3、SQL"><a href="#3、SQL" class="headerlink" title="3、SQL"></a>3、SQL</h1><ol><li><p>什么是SQL</p><pre><code>Structured  Query  Language: 结构化查询语言其实就是定义了操作类型数据库的规则，每一种数据库操作的方式存在不一样的地方，被称为“方言”。</code></pre></li><li><p>SQL通用语法</p><pre><code>1. SQL语句可以单行或多行书写，以分号结尾2. 可以使用空格和缩进来增强语句的可持续性3. MySQL数据库的SQL语句不区分大小写，关键字建议使用大写4. 注释        · 单行注释：  -- 注释的内容                  或  # 注释的内容 （mysql特有）        · 多行注释： / * 注释的内容 * /</code></pre></li><li><p>SQL分类</p><pre><code>1. DDL(Date Definition Language) 数据定义语言    用来定义数据库对象：数据库、表、列等               关键字：crate drop alter2. DML(Date Manipulation Language) 数据操作语言    用来对数据库中表的数据进行增删改              关键字：insert delete update3. DQL(Date Query Language) 数据库查询语言    用来查询数据库表的记录(数据)             关键字：select where4. DCL(Date Control Language) 数据库控制语言    用来定义数据库的访问权限和安全级别及创建用户             关键字： GRANT REVOKE等</code></pre><h2 id="DDL：操作数据库、表"><a href="#DDL：操作数据库、表" class="headerlink" title="DDL：操作数据库、表"></a>DDL：操作数据库、表</h2></li></ol><h3 id="1-操作数据库：CRUD"><a href="#1-操作数据库：CRUD" class="headerlink" title="1.操作数据库：CRUD"></a>1.操作数据库：CRUD</h3><h4 id="1-C-Creat-创建"><a href="#1-C-Creat-创建" class="headerlink" title="1.C(Creat):创建"></a>1.C(Creat):创建</h4><pre><code>* 创建数据库：CRUD        create database 数据库名称* 创建数据库 判断不存在 再进行创建        create database if not exists  ···名称* 创建数据库，并指定字符集        create database 数据库名称 character set 字符集合</code></pre><h4 id="2-R-Rrtrieve-查询"><a href="#2-R-Rrtrieve-查询" class="headerlink" title="2.R(Rrtrieve):查询"></a>2.R(Rrtrieve):查询</h4><pre><code>* 查询所有数据库的名称:        show databases;* 查询某个数据库的字符集:查询某个数据库的创建语句        show create database 数据库名称;</code></pre><h4 id="3-U-Update-修改"><a href="#3-U-Update-修改" class="headerlink" title="3.U(Update):修改"></a>3.U(Update):修改</h4><pre><code>* 修改数据库的字符集        alter database 数据库名称 character set 字符集名称;</code></pre><h4 id="4-D-Delete-删除"><a href="#4-D-Delete-删除" class="headerlink" title="4.D(Delete):删除"></a>4.D(Delete):删除</h4><pre><code>* 删除数据库        drop database 数据库名称;* 判断数据库存在，存在再删除        drop database if exists 数据库名称;</code></pre><h4 id="5-使用数据库"><a href="#5-使用数据库" class="headerlink" title="5.使用数据库"></a>5.使用数据库</h4><pre><code>* 查询当前正在使用的数据库名称        select database();* 使用数据库        use 数据库名称;</code></pre><h3 id="2-操作表"><a href="#2-操作表" class="headerlink" title="2.操作表"></a>2.操作表</h3><h4 id="1-C-Create-创建"><a href="#1-C-Create-创建" class="headerlink" title="1.C(Create):创建"></a>1.C(Create):创建</h4><h5 id="1-语法"><a href="#1-语法" class="headerlink" title="1.语法"></a>1.语法</h5><pre><code>create table 表名(    列名1 数据类型1,    列名2 数据类型2,    ....    列名n 数据类型n);* 注意：最后一列，不需要加逗号(,)</code></pre><h5 id="2-R-Retrieve-：查询"><a href="#2-R-Retrieve-：查询" class="headerlink" title="2. R(Retrieve)：查询"></a>2. R(Retrieve)：查询</h5><pre><code>* 查询某个数据库中所有的表名称     show tables;* 查询表结构      desc 表名;</code></pre><h5 id="3-U-Update-修改-1"><a href="#3-U-Update-修改-1" class="headerlink" title="3. U(Update):修改"></a>3. U(Update):修改</h5><pre><code>1. 修改表名    alter table 表名 rename to 新的表名;2. 修改表的字符集    alter table 表名 character set 字符集名称;3. 添加一列    alter table 表名 add 列名 数据类型;4. 修改列名称 类型    alter table 表名 change 列名 新列别 新数据类型;    alter table 表名 modify 列名 新数据类型;5. 删除列    alter table 表名 drop 列名;</code></pre><h5 id="4-D-Delete-删除-1"><a href="#4-D-Delete-删除-1" class="headerlink" title="4. D(Delete):删除"></a>4. D(Delete):删除</h5><pre><code>* drop table 表名;* drop table  if exists 表名 ;</code></pre><h5 id="数据库类型"><a href="#数据库类型" class="headerlink" title="数据库类型"></a>数据库类型</h5><pre><code>1. int：整数类型2. double:小数类型3. date:日期，只包含年月日，yyyy-MM-dd4. datetime:日期，包含年月日时分秒     yyyy-MM-dd HH:mm:ss5. timestamp:时间错类型    包含年月日时分秒     yyyy-MM-dd HH:mm:ss        * 如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值6. varchar：字符串    * name varchar(20):姓名最大20个字符    * zhangsan 8个字符  张三 2个字符</code></pre><h2 id="DML：增删改表中数据"><a href="#DML：增删改表中数据" class="headerlink" title="DML：增删改表中数据"></a>DML：增删改表中数据</h2><h4 id="1-添加数据："><a href="#1-添加数据：" class="headerlink" title="1. 添加数据："></a>1. 添加数据：</h4><pre><code>* 语法：    * insert into 表名(列名1,列名2,...列名n) values(值1,值2,...值n);* 注意：    1. 列名和值要一一对应。    2. 如果表名后，不定义列名，则默认给所有列添加值        insert into 表名 values(值1,值2,...值n);    3. 除了数字类型，其他类型需要使用引号(单双都可以)引起来</code></pre><h4 id="2-删除数据："><a href="#2-删除数据：" class="headerlink" title="2. 删除数据："></a>2. 删除数据：</h4><pre><code>* 语法：    * delete from 表名 [where 条件]* 注意：    1. 如果不加条件，则删除表中所有记录。    2. 如果要删除所有记录        1. delete from 表名; -- 不推荐使用。有多少条记录就会执行多少次删除操作        2. TRUNCATE TABLE 表名; -- 推荐使用，效率更高 先删除表，然后再创建一张一样的表。</code></pre><h4 id="3-修改数据："><a href="#3-修改数据：" class="headerlink" title="3. 修改数据："></a>3. 修改数据：</h4><pre><code>* 语法：    * update 表名 set 列名1 = 值1, 列名2 = 值2,... [where 条件];* 注意：    1. 如果不加任何条件，则会将表中所有记录全部修改。</code></pre><h2 id="DQL：查询表中的记录"><a href="#DQL：查询表中的记录" class="headerlink" title="DQL：查询表中的记录"></a>DQL：查询表中的记录</h2><pre><code>* select * from 表名;</code></pre><h4 id="1-语法："><a href="#1-语法：" class="headerlink" title="1. 语法："></a>1. 语法：</h4><pre><code>select    字段列表from    表名列表where    条件列表group by    分组字段having    分组之后的条件order by    排序limit    分页限定</code></pre><h4 id="2-基础查询"><a href="#2-基础查询" class="headerlink" title="2. 基础查询"></a>2. 基础查询</h4><pre><code>1. 多个字段的查询    select 字段名1，字段名2... from 表名；    * 注意：        * 如果查询所有字段，则可以使用*来替代字段列表。2. 去除重复：    * distinct3. 计算列    * 一般可以使用四则运算计算一些列的值。（一般只会进行数值型的计算）    * ifnull(表达式1,表达式2)：null参与的运算，计算结果都为null        * 表达式1：哪个字段需要判断是否为null        * 如果该字段为null后的替换值。4. 起别名：    * as：as也可以省略</code></pre><h4 id="3-条件查询"><a href="#3-条件查询" class="headerlink" title="3. 条件查询"></a>3. 条件查询</h4><pre><code>1. where子句后跟条件2. 运算符    * &gt; 、&lt; 、&lt;= 、&gt;= 、= 、&lt;&gt;    * BETWEEN...AND      * IN( 集合)     * LIKE：模糊查询        * 占位符：            * _:单个任意字符            * %：多个任意字符    * IS NULL      * and  或 &amp;&amp;    * or  或 ||     * not  或 !</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;【介绍】MySQL基础知识的总结&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="MySQL" scheme="https://seven1011.github.io/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://seven1011.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Java重点知识总结-day05</title>
    <link href="https://seven1011.github.io/2019/10/04/Java%E9%87%8D%E7%82%B9%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93-day05/"/>
    <id>https://seven1011.github.io/2019/10/04/Java重点知识总结-day05/</id>
    <published>2019-10-04T09:45:52.000Z</published>
    <updated>2019-10-23T13:41:57.250Z</updated>
    
    <content type="html"><![CDATA[<pre><code>【介绍】java学习过程中重点知识的总结-第五天</code></pre><a id="more"></a><h1 id="1-Date类-日期类"><a href="#1-Date类-日期类" class="headerlink" title="1.Date类:日期类"></a>1.Date类:日期类</h1><pre><code>*     构造:*     public Date();//代表当前系统时间的Date对象*     public Date(long time);//代表距离标准时间 time毫秒值的Date对象*     成员方法:    *     public String toString();//Date    重写Object类的toString方法    *     public long getTime();//获取当前Date对象的毫n秒值</code></pre><h1 id="2-DateFormat-日期格式化类-抽象类"><a href="#2-DateFormat-日期格式化类-抽象类" class="headerlink" title="2.DateFormat:日期格式化类 抽象类"></a>2.DateFormat:日期格式化类 抽象类</h1><pre><code>*     具体的子类:SimpleDateFormat*     构造:*     public SimpleDateFormat(String pattern);//以指定的模式创建格式化对象*     成员方法:*     public String format(Date d);//把date对象按照指定的模式 转成字符串*     public Date parse(String s);//把字符串转成Date对象,如果字符串有问题,就会抛出ParseException  </code></pre><h1 id="3-Calendar-日历类"><a href="#3-Calendar-日历类" class="headerlink" title="3.Calendar:日历类"></a>3.Calendar:日历类</h1><pre><code>* 3.1获取Calendar对象     *     public static Calendar getInstance();//返回的是抽象类Calendar的某一个子类* 3.2成员方法:     *     public int get(int field);//获取指定字段的值     *     public void add(int field,int amount);//给指定的字段增加值     *     public void set(int field,int value);//修改指定字段的值     *     public Date getTime();//把Calendar对象转成Date 对象  </code></pre><h1 id="4-System-系统类"><a href="#4-System-系统类" class="headerlink" title="4.System:系统类"></a>4.System:系统类</h1><pre><code>*     public static void exit(0);//结束JVM*     public static void gc();//通知垃圾回收器过来收垃圾*     public static getProperty(String key);//根据键 获取值*     public static long currentTimeMillis();//获取当前系统的毫秒值  </code></pre><h1 id="5-Math-数学类"><a href="#5-Math-数学类" class="headerlink" title="5.Math:数学类"></a>5.Math:数学类</h1><pre><code>1.求最大值 2.求最小值 3.求绝对值    4.求随机数  5.求四舍五入  6.ceil(向上取整) 7.floor(向下取整) 8.pow(求次幂)  </code></pre><h1 id="6-基类数据类型包装类"><a href="#6-基类数据类型包装类" class="headerlink" title="6.基类数据类型包装类"></a>6.基类数据类型包装类</h1><pre><code>* (8中基本类对应的包装类型)* (自动拆箱装箱)  </code></pre><h1 id="7-正则表达式"><a href="#7-正则表达式" class="headerlink" title="7.正则表达式:"></a>7.正则表达式:</h1><pre><code>* boolean b = &quot;普通字符串&quot;.matches(&quot;正则表达式&quot;);</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;【介绍】java学习过程中重点知识的总结-第五天&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://seven1011.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https://seven1011.github.io/tags/java/"/>
    
      <category term="notes" scheme="https://seven1011.github.io/tags/notes/"/>
    
  </entry>
  
  <entry>
    <title>Java重点知识总结-day04</title>
    <link href="https://seven1011.github.io/2019/09/28/Java%E9%87%8D%E7%82%B9%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93-day04/"/>
    <id>https://seven1011.github.io/2019/09/28/Java重点知识总结-day04/</id>
    <published>2019-09-27T16:34:44.000Z</published>
    <updated>2019-10-23T13:41:51.288Z</updated>
    
    <content type="html"><![CDATA[<pre><code>【介绍】java学习过程中重点知识的总结-第四天</code></pre><a id="more"></a><h2 id="1-Object类"><a href="#1-Object类" class="headerlink" title="1.Object类"></a>1.Object类</h2><p> <em>· 是所有类的根类</em></p><pre><code>boolean eauals(Object obj); a.Object类中equals方法,比较 是两个对象地址 ,就是 ==号的作用 b.子类为了改变比较规则,可以重写equals方法     比如:Java提供的String 重写了equals,变成比较两个字符串的内容     比如: 我们自己定义的类,也可以重写equals方法,一般比较两个对象的成员变量的值String toString();//返回该对象的字符串表示 ----&gt;hashCode()返回该对象的数字表示 a.Object类中的toString,返回值: &quot;包名.类名@地址值&quot; b.子类为了快速打印一个对象的信息,一般重写toString    在toString方法中,返回需要成员变量的值 注意:    syso(对象) &lt;====&gt; syso(对象.toString());</code></pre><h2 id="2-异常"><a href="#2-异常" class="headerlink" title="2.异常"></a>2.异常</h2><pre><code>异常的根类:    Throwable        --Exception:异常类            -- 编译时异常:编译时报错            -- 运行时异常:运行时报错        --Error:错误类(不研究,出现了错误,改代码)异常的抛出:    throw new 异常类(&quot;&quot;);异常的处理:  不处理,再次声明抛出处理        在抛出异常的方法上  throws xxxException       然后该方法的调用者就必须处理这个异常   捕获处理:        标准的方法:      try{            可能出现问题的代码      }catch(所有可能出现异常的父类 变量名){            处理异常,打印,提示,写入日志      }finally{            释放资源:            1.IO流  2.网络连接 3.数据库连接        }        了解一下:       一次捕获多次处理: 一个try 多个catch  (多个catch中 必须是异常子类在前,父类在后)       多次捕获多次处理: 多个try,每个try多应一个catch        一次捕获一次处理(最常用的):一个try一个catch(catch中异常类必须所有可能出现异常的父类)自定义异常:    固定套路:    1.异常类名 必须用Exception结尾    2.异常类必须 继承 Exception 或者RuntimeException    3.异常类一般提供两个构造: 无参构造+String参数构造编译时异常和运行时异常 怎么区分别:    1.编译时异常 在编译的时候会报错的 (需要我们去处理)    2.运行时异常 在编译的时候不会报错    只要定义一个方法,在方法中抛出一个异常对象,如果编译报错那么就是编译时异常    如果编译成功,那么就是运行时异常</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;【介绍】java学习过程中重点知识的总结-第四天&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://seven1011.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https://seven1011.github.io/tags/java/"/>
    
      <category term="notes" scheme="https://seven1011.github.io/tags/notes/"/>
    
  </entry>
  
  <entry>
    <title>JDBC基础学习篇--day1</title>
    <link href="https://seven1011.github.io/2019/09/27/JDBC%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AF%87-day1/"/>
    <id>https://seven1011.github.io/2019/09/27/JDBC基础学习篇-day1/</id>
    <published>2019-09-27T09:25:27.000Z</published>
    <updated>2019-10-23T13:42:04.199Z</updated>
    
    <content type="html"><![CDATA[<pre><code>【介绍】JDBC基础学习，主要包括JDBC的基本概念、JDBC快速入门以及JDBC中各种接口和类的详解  </code></pre><a id="more"></a><h2 id="主要学习内容："><a href="#主要学习内容：" class="headerlink" title="主要学习内容："></a>主要学习内容：</h2><p>&#160;&#160;1. JDBC基本概念<br>&#160;&#160;2. 快速入门<br>&#160;&#160;3. 对JDBC中各个接口和类详解  </p><h2 id="JDBC："><a href="#JDBC：" class="headerlink" title="JDBC："></a>JDBC：</h2><p>基本概念：Java DateBase Connectivity Java 数据库连接，用Java语言操作数据库。JDBC的实质是由sun公司定义的一套操作数据库的接口，我们使用这套接口（JDBC编程），执行驱动jar包中的实现类。  </p><h3 id="快速入门："><a href="#快速入门：" class="headerlink" title="快速入门："></a>快速入门：</h3><ul><li>步骤  <blockquote><ol><li>导入驱动jar包：mysql-connector-java-5.1.37-bin.jar  <pre><code>1. 复制mysql-connector-java-5.1.37-bin.jar到项目的libs目录下  2. 右键--&gt;Add As Library  </code></pre></li><li>注册驱动</li><li>获取数据库连接对象</li><li>定义sql</li><li>执行sql，接受返回结果</li><li>处理结果</li><li>释放资源</li></ol></blockquote></li><li>代码    <div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    //1.导入驱动jar包</span><br><span class="line">    //2.注册驱动</span><br><span class="line">    Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br><span class="line">    //3.获取数据库的连接对象</span><br><span class="line">    Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/stu&quot;, &quot;root&quot;, &quot;root0809&quot;);</span><br><span class="line">    //4.定义sql语句</span><br><span class="line">    String sql = &quot;update account set balance =   100 where id    =   1&quot;;</span><br><span class="line">    //5.获取执行sql的对象 Statement</span><br><span class="line">    Statement stmt = conn.createStatement();</span><br><span class="line">    //6.执行sql</span><br><span class="line">    int count = stmt.executeUpdate(sql);</span><br><span class="line">    //7.处理结果</span><br><span class="line">    System.out.println(count);</span><br><span class="line">    //8.释放资源</span><br><span class="line">    stmt.close();</span><br><span class="line">    conn.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li></ul><h3 id="各个对象详解："><a href="#各个对象详解：" class="headerlink" title="各个对象详解："></a>各个对象详解：</h3><h4 id="1-驱动管理对象：DriverManager"><a href="#1-驱动管理对象：DriverManager" class="headerlink" title="1.驱动管理对象：DriverManager"></a>1.驱动管理对象：DriverManager</h4><ul><li>功能：</li></ul><blockquote><ol><li>注册驱动：告诉计算及使用哪一个数据驱动jar<br>   注册驱动DriverManager：static void registerDriver(Driver driver)  </li><li>获取数据库连接:<br>· 方法：static Connection getConnection(String url, String user, String password)<br>· 参数介绍：  <pre><code>url:指定连接的路径        语法：jdbc:mysql://ip地址(域名):端口号/数据库名称        例子：jdbc:mysql://localhost:3306/db3        细节：如果连接的是本机mysql服务器，并且mysql服务默认端口是3306，则url可以简写为：jdbc:mysql:///数据库名称  user:用户名  password:密码  </code></pre></li></ol></blockquote><h4 id="2-数据库连接对象：Connection"><a href="#2-数据库连接对象：Connection" class="headerlink" title="2.数据库连接对象：Connection"></a>2.数据库连接对象：Connection</h4><ul><li>功能<br>   1.获取执行sql的对象<pre><code>· Statement creatStatement()· PreparedStatement prepareStatement(String sql)</code></pre>   2.管理事物：<pre><code>* 开启事务：setAutoCommit(boolean autoCommit):调用该方法设置参数为false，即开启事务。* 提交事务：commit()* 回滚事务：roolback()  </code></pre>  3.Statement:执行sql的对象<pre><code>· 执行sql    1.boolean execute(String sql):可以执行任意的sql    2. int executeUpdate(String sql) ：执行DML（insert、update、delete）语句、DDL(create，alter、drop)语句          * 返回值：影响的行数，可以通过这个影响的行数判断DML语句是否执行成功 返回值&gt;0的则执行成功，反之，则失败。    3. ResultSet executeQuery(String sql)  ：执行DQL（select)语句</code></pre>  4.ResultSet:结果及对象，封装查询结果<pre><code>* boolean next(): 游标向下移动一行，判断当前行是否是最后一行末尾(是否有数据)，如果是，则返回false，如果不是则返回true* getXxx(参数):获取数据    * Xxx：代表数据类型   如： int getInt() ,    String getString()    * 参数：        1. int：代表列的编号,从1开始   如： getString(1)        2. String：代表列名称。 如： getDouble(&quot;balance&quot;)* 注意：    * 使用步骤：        1. 游标向下移动一行        2. 判断是否有数据        3. 获取数据  </code></pre>  5.PreparedStatement：执行sql的对象  <pre><code>1. SQL注入问题：在拼接sql时，有一些sql的特殊关键字参与字符串的拼接。会造成安全性问题    1. 输入用户随便，输入密码：a&apos; or &apos;a&apos; = &apos;a    2. sql：select * from user where username = &apos;fhdsjkf&apos; and password = &apos;a&apos; or &apos;a&apos; = &apos;a&apos; 2. 解决sql注入问题：使用PreparedStatement对象来解决3. 预编译的SQL：参数使用?作为占位符4. 步骤：        1. 导入驱动jar包 mysql-connector-java-5.1.37-bin.jar        2. 注册驱动        3. 获取数据库连接对象 Connection        4. 定义sql            * 注意：sql的参数使用？作为占位符。 如：select * from user where username = ? and password = ?;        5. 获取执行sql语句的对象 PreparedStatement  Connection.prepareStatement(String sql)         6. 给？赋值：            * 方法： setXxx(参数1,参数2)                * 参数1：？的位置编号 从1 开始                * 参数2：？的值        7. 执行sql，接受返回结果，不需要传递sql语句        8. 处理结果        9. 释放资源5. 注意：后期都会使用PreparedStatement来完成增删改查的所有操作    1. 可以防止SQL注入    2. 效率更高</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;【介绍】JDBC基础学习，主要包括JDBC的基本概念、JDBC快速入门以及JDBC中各种接口和类的详解  &lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="JDBC" scheme="https://seven1011.github.io/categories/JDBC/"/>
    
    
      <category term="JDBC" scheme="https://seven1011.github.io/tags/JDBC/"/>
    
      <category term="javaweb" scheme="https://seven1011.github.io/tags/javaweb/"/>
    
  </entry>
  
  <entry>
    <title>Java重点知识总结-day03</title>
    <link href="https://seven1011.github.io/2019/09/26/Java%E9%87%8D%E7%82%B9%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93-day03/"/>
    <id>https://seven1011.github.io/2019/09/26/Java重点知识总结-day03/</id>
    <published>2019-09-26T15:24:51.000Z</published>
    <updated>2019-10-23T13:41:44.744Z</updated>
    
    <content type="html"><![CDATA[<pre><code>【介绍】java学习过程中重点知识的总结-第三天</code></pre><a id="more"></a><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><pre><code>·多态，向下转型具体什么时候用    复习：        1.多态的使用前提：            a.必须有继承或者实现            b.必须有方法的重写            c.表现形式：                父类类型 变量名 = new 子类类型();                接口类型 变量名 = new 实现类类型();        2.多态的成员的特点            使用多态调用成员变量：编译看左边，运行看左边            使用多态调用成员方法：编译看左边，运行看右边        3.多态的弊端：            不能调用子类特有的成员方法，只能调用父类共有的成员方法        4.如果就是想调用子类特有的方法，怎么办？            向下转型，把父类类型的变量，转会到对应的子类类型上·接口有什么构造方法吗？抽象类？有什么作用？        接口没有构造方法        抽象类是有构造方法的                因为所有的类，都有一个共同的父类                    例：public class Person implements Police{                                    public Person(){                                            super();                                    }                                }·this和super的语句形式        this():调用本类构造方法        super():调用父类的构造方法        this()和super()不能同时出现在一个构造方法的第一行</code></pre><h2 id="1-static"><a href="#1-static" class="headerlink" title="1.static"></a>1.static</h2><pre><code>a.什么时候用static来修饰成员    当这个成员不属于某一个对象，而是属于所有对象。或者属于这个类，南无需要static来修饰它b.被static修饰的成员有什么特点    i.存在方法区中的静态区，只有一个空间    ii.静态时有限于对象存在    iii.如何访问静态成员：            对象名.静态成员; //这是可以的，但是不建议            类名.静态成员; //建议使用</code></pre><h2 id="2-final"><a href="#2-final" class="headerlink" title="2.final"></a>2.final</h2><pre><code>final 修饰类(太监类)  不能被继承(没有子类)  但是可以是其他类的子类final 修饰方法（最终方法） 子类不能被重写final 修饰成员变量    a.这个成员变量在创建对象之前必须初始化        （直接复制，在构造方法中赋值）    b.只能赋值一次final 修饰局部变量    a.基本类型        该变量只能赋值一次（实际上就是常量）    b.引用类型        该引用类型的变量保存的地址不能改变        但是地址指向空间中的内存可以改变        final  Person p = new Person();        p = new Person();错误的        p.name = ;正确的        p.age = 18;正确的</code></pre><h2 id="3-包"><a href="#3-包" class="headerlink" title="3.包"></a>3.包</h2><pre><code>导包的关键字 import全限定类名  包名.类名（可以不用导包）后期说反射，用到全限定类名</code></pre><h2 id="4-权限修饰符"><a href="#4-权限修饰符" class="headerlink" title="4.权限修饰符"></a>4.权限修饰符</h2><pre><code>public protected default(默认，可以不写) private如果一个成员指向在本类中使用 用private修饰如果一个成员只想在本类中和本包中使用 不写修饰如果一个成员只想在本类中和本包中或者其他包的子类中使用 用protected修饰如果一个成员想在所有类中都可以使用 用public修饰</code></pre><h2 id="5-内部类"><a href="#5-内部类" class="headerlink" title="5.内部类"></a>5.内部类</h2><pre><code>根据内部类定义位置不同的分类    a.成员内部类定义类中方法外        在其他类中如何创建该类的对象        固定格式                外部类名.内部类名  变量名 = new 外部类()/new内部类();    b.局部内部类定义方法中        在其他类中，是无法使用的        只能局部位置使用</code></pre><h2 id="6-静态代码快"><a href="#6-静态代码快" class="headerlink" title="6.静态代码快"></a>6.静态代码快</h2><pre><code> 代码块，在成员位置使用大括号括起来的一堆代码           public class Person{       静态代码块       static{           代码块       }       public void show(){       }   }·特点   1.当我们使用到一个类时,那么这类中的静态代码块自动执行   2.只会执行一次,第一次使用该类,就立刻执行   3.在同一个类中,静态代码块的优先级很高,比构造方法优先,比main方法优先   4.作用       用来初始化类中某些功能(mysql的数据库驱动的加载)</code></pre><h2 id="7-匿名内部类"><a href="#7-匿名内部类" class="headerlink" title="7.匿名内部类"></a>7.匿名内部类</h2><pre><code>a.作用    快速创建 抽象类的子类对象,接口的实现类对象.b.格式    第一种        new 抽象类(){            重写抽象类中所有的方法        };    第二种        new 抽象类(){            重写抽象类中所有的方法        }.重写后的方法();    第三种        接口类型  变量名 = new 接口(){            重写接口中所有的方法            };       </code></pre>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;【介绍】java学习过程中重点知识的总结-第三天&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://seven1011.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https://seven1011.github.io/tags/java/"/>
    
      <category term="notes" scheme="https://seven1011.github.io/tags/notes/"/>
    
  </entry>
  
  <entry>
    <title>Java重点知识总结-day02</title>
    <link href="https://seven1011.github.io/2019/09/25/Java%E9%87%8D%E7%82%B9%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93-day02/"/>
    <id>https://seven1011.github.io/2019/09/25/Java重点知识总结-day02/</id>
    <published>2019-09-25T09:13:51.000Z</published>
    <updated>2019-10-23T13:41:30.716Z</updated>
    
    <content type="html"><![CDATA[<pre><code>【介绍】java学习过程中重点知识的总结-第二天</code></pre><a id="more"></a><h4 id="1-this和super"><a href="#1-this和super" class="headerlink" title="1.this和super"></a>1.this和super</h4><pre><code>- 作用:    this: 区分本类的成员变量和局部变量同名情况    super:区分父类的成员变量和局部变量同名情况- 用法:    this.成员变量名;//访问本类的成员变量    this.成员方法名();//调用本类成员方法(this可以省略)    super.成员变量名;//访问父类的成员变量    super.成员方法名();//调用父类的成员方法(super不可以省略)</code></pre><h4 id="2-扩展"><a href="#2-扩展" class="headerlink" title="2.扩展:"></a>2.扩展:</h4><pre><code>this(参数);//调用本类的其他构造,具体是哪一个构造,由参数类型决定super(参数)://调用父类的构造,具体哪一个构造,由参数类型决定结论:a.子类中任何一个构造,都会无条件先调用父类的无参构造        b.我们可以通过 super(参数),调用父类中指定参数的构造</code></pre><h4 id="3-方法的重写"><a href="#3-方法的重写" class="headerlink" title="3.方法的重写:"></a>3.方法的重写:</h4><pre><code>- 在子类从 出现了和父类一模一样的方法(修饰符可以不一样) 那么子类中这个方法我们重写后的方法     a.注意事项            1: 子类和父类中重写的那个方法权限可以不一样,子类方法权限&gt;=父类方法权限            2.如果父类的方法是private修饰,子类不能重写     b.什么时候需要进行方法的重写            父类中方法,太low,不适用,不完善,那么子类需要自己重写他,自己实现他</code></pre><h4 id="4-抽象类"><a href="#4-抽象类" class="headerlink" title="4.抽象类"></a>4.抽象类</h4><pre><code>- 概念:    什么叫抽象类: 只要一个类 是abstract修饰的那么这个类就是抽象类和这个类中有没有抽象                 方法,没有必然的联系    什么叫抽象方法:                 方法由abstract修饰,并且没有方法体的方法                    一个抽象类的 是可以没有抽象方法,那么这个类的作用不允许你创建对象  - 作用:             不能创建对象,天生作为父类- 抽象类中的抽象方法有什么作用?        1.抽象类中的抽象方法不是为了调用的        2.为了强制子类去重写</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;pre&gt;&lt;code&gt;【介绍】java学习过程中重点知识的总结-第二天&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://seven1011.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https://seven1011.github.io/tags/java/"/>
    
      <category term="notes" scheme="https://seven1011.github.io/tags/notes/"/>
    
  </entry>
  
</feed>
